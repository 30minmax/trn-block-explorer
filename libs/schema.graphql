schema {
	query: query_root
	mutation: mutation_root
	subscription: subscription_root
}

"""
whether this query should be cached (Hasura Cloud only)
"""
directive @cached(
	"""
	measured in seconds
	"""
	ttl: Int! = 60

	"""
	refresh the cache entry
	"""
	refresh: Boolean! = false
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
	_eq: Boolean
	_gt: Boolean
	_gte: Boolean
	_in: [Boolean!]
	_is_null: Boolean
	_lt: Boolean
	_lte: Boolean
	_neq: Boolean
	_nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
	_eq: Int
	_gt: Int
	_gte: Int
	_in: [Int!]
	_is_null: Boolean
	_lt: Int
	_lte: Int
	_neq: Int
	_nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
	_eq: String
	_gt: String
	_gte: String

	"""
	does the column match the given case-insensitive pattern
	"""
	_ilike: String
	_in: [String!]

	"""
	does the column match the given POSIX regular expression, case insensitive
	"""
	_iregex: String
	_is_null: Boolean

	"""
	does the column match the given pattern
	"""
	_like: String
	_lt: String
	_lte: String
	_neq: String

	"""
	does the column NOT match the given case-insensitive pattern
	"""
	_nilike: String
	_nin: [String!]

	"""
	does the column NOT match the given POSIX regular expression, case insensitive
	"""
	_niregex: String

	"""
	does the column NOT match the given pattern
	"""
	_nlike: String

	"""
	does the column NOT match the given POSIX regular expression, case sensitive
	"""
	_nregex: String

	"""
	does the column NOT match the given SQL regular expression
	"""
	_nsimilar: String

	"""
	does the column match the given POSIX regular expression, case sensitive
	"""
	_regex: String

	"""
	does the column match the given SQL regular expression
	"""
	_similar: String
}

type archive_archive_mutation_frontend {
	"""
	delete data from the table: "block"
	"""
	delete_block(
		"""
		filter the rows which have to be deleted
		"""
		where: archive_block_bool_exp!
	): archive_block_mutation_response

	"""
	delete single row from the table: "block"
	"""
	delete_block_by_pk(id: bpchar!): archive_block

	"""
	delete data from the table: "call"
	"""
	delete_call(
		"""
		filter the rows which have to be deleted
		"""
		where: archive_call_bool_exp!
	): archive_call_mutation_response

	"""
	delete single row from the table: "call"
	"""
	delete_call_by_pk(id: String!): archive_call

	"""
	delete data from the table: "contracts_contract_emitted"
	"""
	delete_contracts_contract_emitted(
		"""
		filter the rows which have to be deleted
		"""
		where: archive_contracts_contract_emitted_bool_exp!
	): archive_contracts_contract_emitted_mutation_response

	"""
	delete single row from the table: "contracts_contract_emitted"
	"""
	delete_contracts_contract_emitted_by_pk(
		event_id: bpchar!
	): archive_contracts_contract_emitted

	"""
	delete data from the table: "event"
	"""
	delete_event(
		"""
		filter the rows which have to be deleted
		"""
		where: archive_event_bool_exp!
	): archive_event_mutation_response

	"""
	delete single row from the table: "event"
	"""
	delete_event_by_pk(id: bpchar!): archive_event

	"""
	delete data from the table: "extrinsic"
	"""
	delete_extrinsic(
		"""
		filter the rows which have to be deleted
		"""
		where: archive_extrinsic_bool_exp!
	): archive_extrinsic_mutation_response

	"""
	delete single row from the table: "extrinsic"
	"""
	delete_extrinsic_by_pk(id: bpchar!): archive_extrinsic

	"""
	delete data from the table: "frontier_ethereum_transaction"
	"""
	delete_frontier_ethereum_transaction(
		"""
		filter the rows which have to be deleted
		"""
		where: archive_frontier_ethereum_transaction_bool_exp!
	): archive_frontier_ethereum_transaction_mutation_response

	"""
	delete single row from the table: "frontier_ethereum_transaction"
	"""
	delete_frontier_ethereum_transaction_by_pk(
		call_id: String!
	): archive_frontier_ethereum_transaction

	"""
	delete data from the table: "frontier_evm_log"
	"""
	delete_frontier_evm_log(
		"""
		filter the rows which have to be deleted
		"""
		where: archive_frontier_evm_log_bool_exp!
	): archive_frontier_evm_log_mutation_response

	"""
	delete single row from the table: "frontier_evm_log"
	"""
	delete_frontier_evm_log_by_pk(event_id: bpchar!): archive_frontier_evm_log

	"""
	delete data from the table: "metadata"
	"""
	delete_metadata(
		"""
		filter the rows which have to be deleted
		"""
		where: archive_metadata_bool_exp!
	): archive_metadata_mutation_response

	"""
	delete single row from the table: "metadata"
	"""
	delete_metadata_by_pk(id: String!): archive_metadata

	"""
	insert data into the table: "block"
	"""
	insert_block(
		"""
		the rows to be inserted
		"""
		objects: [archive_block_insert_input!]!

		"""
		upsert condition
		"""
		on_conflict: archive_block_on_conflict
	): archive_block_mutation_response

	"""
	insert a single row into the table: "block"
	"""
	insert_block_one(
		"""
		the row to be inserted
		"""
		object: archive_block_insert_input!

		"""
		upsert condition
		"""
		on_conflict: archive_block_on_conflict
	): archive_block

	"""
	insert data into the table: "call"
	"""
	insert_call(
		"""
		the rows to be inserted
		"""
		objects: [archive_call_insert_input!]!

		"""
		upsert condition
		"""
		on_conflict: archive_call_on_conflict
	): archive_call_mutation_response

	"""
	insert a single row into the table: "call"
	"""
	insert_call_one(
		"""
		the row to be inserted
		"""
		object: archive_call_insert_input!

		"""
		upsert condition
		"""
		on_conflict: archive_call_on_conflict
	): archive_call

	"""
	insert data into the table: "contracts_contract_emitted"
	"""
	insert_contracts_contract_emitted(
		"""
		the rows to be inserted
		"""
		objects: [archive_contracts_contract_emitted_insert_input!]!

		"""
		upsert condition
		"""
		on_conflict: archive_contracts_contract_emitted_on_conflict
	): archive_contracts_contract_emitted_mutation_response

	"""
	insert a single row into the table: "contracts_contract_emitted"
	"""
	insert_contracts_contract_emitted_one(
		"""
		the row to be inserted
		"""
		object: archive_contracts_contract_emitted_insert_input!

		"""
		upsert condition
		"""
		on_conflict: archive_contracts_contract_emitted_on_conflict
	): archive_contracts_contract_emitted

	"""
	insert data into the table: "event"
	"""
	insert_event(
		"""
		the rows to be inserted
		"""
		objects: [archive_event_insert_input!]!

		"""
		upsert condition
		"""
		on_conflict: archive_event_on_conflict
	): archive_event_mutation_response

	"""
	insert a single row into the table: "event"
	"""
	insert_event_one(
		"""
		the row to be inserted
		"""
		object: archive_event_insert_input!

		"""
		upsert condition
		"""
		on_conflict: archive_event_on_conflict
	): archive_event

	"""
	insert data into the table: "extrinsic"
	"""
	insert_extrinsic(
		"""
		the rows to be inserted
		"""
		objects: [archive_extrinsic_insert_input!]!

		"""
		upsert condition
		"""
		on_conflict: archive_extrinsic_on_conflict
	): archive_extrinsic_mutation_response

	"""
	insert a single row into the table: "extrinsic"
	"""
	insert_extrinsic_one(
		"""
		the row to be inserted
		"""
		object: archive_extrinsic_insert_input!

		"""
		upsert condition
		"""
		on_conflict: archive_extrinsic_on_conflict
	): archive_extrinsic

	"""
	insert data into the table: "frontier_ethereum_transaction"
	"""
	insert_frontier_ethereum_transaction(
		"""
		the rows to be inserted
		"""
		objects: [archive_frontier_ethereum_transaction_insert_input!]!

		"""
		upsert condition
		"""
		on_conflict: archive_frontier_ethereum_transaction_on_conflict
	): archive_frontier_ethereum_transaction_mutation_response

	"""
	insert a single row into the table: "frontier_ethereum_transaction"
	"""
	insert_frontier_ethereum_transaction_one(
		"""
		the row to be inserted
		"""
		object: archive_frontier_ethereum_transaction_insert_input!

		"""
		upsert condition
		"""
		on_conflict: archive_frontier_ethereum_transaction_on_conflict
	): archive_frontier_ethereum_transaction

	"""
	insert data into the table: "frontier_evm_log"
	"""
	insert_frontier_evm_log(
		"""
		the rows to be inserted
		"""
		objects: [archive_frontier_evm_log_insert_input!]!

		"""
		upsert condition
		"""
		on_conflict: archive_frontier_evm_log_on_conflict
	): archive_frontier_evm_log_mutation_response

	"""
	insert a single row into the table: "frontier_evm_log"
	"""
	insert_frontier_evm_log_one(
		"""
		the row to be inserted
		"""
		object: archive_frontier_evm_log_insert_input!

		"""
		upsert condition
		"""
		on_conflict: archive_frontier_evm_log_on_conflict
	): archive_frontier_evm_log

	"""
	insert data into the table: "metadata"
	"""
	insert_metadata(
		"""
		the rows to be inserted
		"""
		objects: [archive_metadata_insert_input!]!

		"""
		upsert condition
		"""
		on_conflict: archive_metadata_on_conflict
	): archive_metadata_mutation_response

	"""
	insert a single row into the table: "metadata"
	"""
	insert_metadata_one(
		"""
		the row to be inserted
		"""
		object: archive_metadata_insert_input!

		"""
		upsert condition
		"""
		on_conflict: archive_metadata_on_conflict
	): archive_metadata

	"""
	update data of the table: "block"
	"""
	update_block(
		"""
		increments the numeric columns with given value of the filtered values
		"""
		_inc: archive_block_inc_input

		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: archive_block_set_input

		"""
		filter the rows which have to be updated
		"""
		where: archive_block_bool_exp!
	): archive_block_mutation_response

	"""
	update single row of the table: "block"
	"""
	update_block_by_pk(
		"""
		increments the numeric columns with given value of the filtered values
		"""
		_inc: archive_block_inc_input

		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: archive_block_set_input
		pk_columns: archive_block_pk_columns_input!
	): archive_block

	"""
	update multiples rows of table: "block"
	"""
	update_block_many(
		"""
		updates to execute, in order
		"""
		updates: [archive_block_updates!]!
	): [archive_block_mutation_response]

	"""
	update data of the table: "call"
	"""
	update_call(
		"""
		append existing jsonb value of filtered columns with new jsonb value
		"""
		_append: archive_call_append_input

		"""
		delete the field or element with specified path (for JSON arrays, negative integers count from the end)
		"""
		_delete_at_path: archive_call_delete_at_path_input

		"""
		delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
		"""
		_delete_elem: archive_call_delete_elem_input

		"""
		delete key/value pair or string element. key/value pairs are matched based on their key value
		"""
		_delete_key: archive_call_delete_key_input

		"""
		increments the numeric columns with given value of the filtered values
		"""
		_inc: archive_call_inc_input

		"""
		prepend existing jsonb value of filtered columns with new jsonb value
		"""
		_prepend: archive_call_prepend_input

		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: archive_call_set_input

		"""
		filter the rows which have to be updated
		"""
		where: archive_call_bool_exp!
	): archive_call_mutation_response

	"""
	update single row of the table: "call"
	"""
	update_call_by_pk(
		"""
		append existing jsonb value of filtered columns with new jsonb value
		"""
		_append: archive_call_append_input

		"""
		delete the field or element with specified path (for JSON arrays, negative integers count from the end)
		"""
		_delete_at_path: archive_call_delete_at_path_input

		"""
		delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
		"""
		_delete_elem: archive_call_delete_elem_input

		"""
		delete key/value pair or string element. key/value pairs are matched based on their key value
		"""
		_delete_key: archive_call_delete_key_input

		"""
		increments the numeric columns with given value of the filtered values
		"""
		_inc: archive_call_inc_input

		"""
		prepend existing jsonb value of filtered columns with new jsonb value
		"""
		_prepend: archive_call_prepend_input

		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: archive_call_set_input
		pk_columns: archive_call_pk_columns_input!
	): archive_call

	"""
	update multiples rows of table: "call"
	"""
	update_call_many(
		"""
		updates to execute, in order
		"""
		updates: [archive_call_updates!]!
	): [archive_call_mutation_response]

	"""
	update data of the table: "contracts_contract_emitted"
	"""
	update_contracts_contract_emitted(
		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: archive_contracts_contract_emitted_set_input

		"""
		filter the rows which have to be updated
		"""
		where: archive_contracts_contract_emitted_bool_exp!
	): archive_contracts_contract_emitted_mutation_response

	"""
	update single row of the table: "contracts_contract_emitted"
	"""
	update_contracts_contract_emitted_by_pk(
		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: archive_contracts_contract_emitted_set_input
		pk_columns: archive_contracts_contract_emitted_pk_columns_input!
	): archive_contracts_contract_emitted

	"""
	update multiples rows of table: "contracts_contract_emitted"
	"""
	update_contracts_contract_emitted_many(
		"""
		updates to execute, in order
		"""
		updates: [archive_contracts_contract_emitted_updates!]!
	): [archive_contracts_contract_emitted_mutation_response]

	"""
	update data of the table: "event"
	"""
	update_event(
		"""
		append existing jsonb value of filtered columns with new jsonb value
		"""
		_append: archive_event_append_input

		"""
		delete the field or element with specified path (for JSON arrays, negative integers count from the end)
		"""
		_delete_at_path: archive_event_delete_at_path_input

		"""
		delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
		"""
		_delete_elem: archive_event_delete_elem_input

		"""
		delete key/value pair or string element. key/value pairs are matched based on their key value
		"""
		_delete_key: archive_event_delete_key_input

		"""
		increments the numeric columns with given value of the filtered values
		"""
		_inc: archive_event_inc_input

		"""
		prepend existing jsonb value of filtered columns with new jsonb value
		"""
		_prepend: archive_event_prepend_input

		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: archive_event_set_input

		"""
		filter the rows which have to be updated
		"""
		where: archive_event_bool_exp!
	): archive_event_mutation_response

	"""
	update single row of the table: "event"
	"""
	update_event_by_pk(
		"""
		append existing jsonb value of filtered columns with new jsonb value
		"""
		_append: archive_event_append_input

		"""
		delete the field or element with specified path (for JSON arrays, negative integers count from the end)
		"""
		_delete_at_path: archive_event_delete_at_path_input

		"""
		delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
		"""
		_delete_elem: archive_event_delete_elem_input

		"""
		delete key/value pair or string element. key/value pairs are matched based on their key value
		"""
		_delete_key: archive_event_delete_key_input

		"""
		increments the numeric columns with given value of the filtered values
		"""
		_inc: archive_event_inc_input

		"""
		prepend existing jsonb value of filtered columns with new jsonb value
		"""
		_prepend: archive_event_prepend_input

		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: archive_event_set_input
		pk_columns: archive_event_pk_columns_input!
	): archive_event

	"""
	update multiples rows of table: "event"
	"""
	update_event_many(
		"""
		updates to execute, in order
		"""
		updates: [archive_event_updates!]!
	): [archive_event_mutation_response]

	"""
	update data of the table: "extrinsic"
	"""
	update_extrinsic(
		"""
		append existing jsonb value of filtered columns with new jsonb value
		"""
		_append: archive_extrinsic_append_input

		"""
		delete the field or element with specified path (for JSON arrays, negative integers count from the end)
		"""
		_delete_at_path: archive_extrinsic_delete_at_path_input

		"""
		delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
		"""
		_delete_elem: archive_extrinsic_delete_elem_input

		"""
		delete key/value pair or string element. key/value pairs are matched based on their key value
		"""
		_delete_key: archive_extrinsic_delete_key_input

		"""
		increments the numeric columns with given value of the filtered values
		"""
		_inc: archive_extrinsic_inc_input

		"""
		prepend existing jsonb value of filtered columns with new jsonb value
		"""
		_prepend: archive_extrinsic_prepend_input

		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: archive_extrinsic_set_input

		"""
		filter the rows which have to be updated
		"""
		where: archive_extrinsic_bool_exp!
	): archive_extrinsic_mutation_response

	"""
	update single row of the table: "extrinsic"
	"""
	update_extrinsic_by_pk(
		"""
		append existing jsonb value of filtered columns with new jsonb value
		"""
		_append: archive_extrinsic_append_input

		"""
		delete the field or element with specified path (for JSON arrays, negative integers count from the end)
		"""
		_delete_at_path: archive_extrinsic_delete_at_path_input

		"""
		delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
		"""
		_delete_elem: archive_extrinsic_delete_elem_input

		"""
		delete key/value pair or string element. key/value pairs are matched based on their key value
		"""
		_delete_key: archive_extrinsic_delete_key_input

		"""
		increments the numeric columns with given value of the filtered values
		"""
		_inc: archive_extrinsic_inc_input

		"""
		prepend existing jsonb value of filtered columns with new jsonb value
		"""
		_prepend: archive_extrinsic_prepend_input

		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: archive_extrinsic_set_input
		pk_columns: archive_extrinsic_pk_columns_input!
	): archive_extrinsic

	"""
	update multiples rows of table: "extrinsic"
	"""
	update_extrinsic_many(
		"""
		updates to execute, in order
		"""
		updates: [archive_extrinsic_updates!]!
	): [archive_extrinsic_mutation_response]

	"""
	update data of the table: "frontier_ethereum_transaction"
	"""
	update_frontier_ethereum_transaction(
		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: archive_frontier_ethereum_transaction_set_input

		"""
		filter the rows which have to be updated
		"""
		where: archive_frontier_ethereum_transaction_bool_exp!
	): archive_frontier_ethereum_transaction_mutation_response

	"""
	update single row of the table: "frontier_ethereum_transaction"
	"""
	update_frontier_ethereum_transaction_by_pk(
		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: archive_frontier_ethereum_transaction_set_input
		pk_columns: archive_frontier_ethereum_transaction_pk_columns_input!
	): archive_frontier_ethereum_transaction

	"""
	update multiples rows of table: "frontier_ethereum_transaction"
	"""
	update_frontier_ethereum_transaction_many(
		"""
		updates to execute, in order
		"""
		updates: [archive_frontier_ethereum_transaction_updates!]!
	): [archive_frontier_ethereum_transaction_mutation_response]

	"""
	update data of the table: "frontier_evm_log"
	"""
	update_frontier_evm_log(
		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: archive_frontier_evm_log_set_input

		"""
		filter the rows which have to be updated
		"""
		where: archive_frontier_evm_log_bool_exp!
	): archive_frontier_evm_log_mutation_response

	"""
	update single row of the table: "frontier_evm_log"
	"""
	update_frontier_evm_log_by_pk(
		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: archive_frontier_evm_log_set_input
		pk_columns: archive_frontier_evm_log_pk_columns_input!
	): archive_frontier_evm_log

	"""
	update multiples rows of table: "frontier_evm_log"
	"""
	update_frontier_evm_log_many(
		"""
		updates to execute, in order
		"""
		updates: [archive_frontier_evm_log_updates!]!
	): [archive_frontier_evm_log_mutation_response]

	"""
	update data of the table: "metadata"
	"""
	update_metadata(
		"""
		increments the numeric columns with given value of the filtered values
		"""
		_inc: archive_metadata_inc_input

		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: archive_metadata_set_input

		"""
		filter the rows which have to be updated
		"""
		where: archive_metadata_bool_exp!
	): archive_metadata_mutation_response

	"""
	update single row of the table: "metadata"
	"""
	update_metadata_by_pk(
		"""
		increments the numeric columns with given value of the filtered values
		"""
		_inc: archive_metadata_inc_input

		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: archive_metadata_set_input
		pk_columns: archive_metadata_pk_columns_input!
	): archive_metadata

	"""
	update multiples rows of table: "metadata"
	"""
	update_metadata_many(
		"""
		updates to execute, in order
		"""
		updates: [archive_metadata_updates!]!
	): [archive_metadata_mutation_response]
}

type archive_archive_query {
	"""
	fetch data from the table: "block"
	"""
	block(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_block_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_block_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_block_bool_exp
	): [archive_block!]!

	"""
	fetch aggregated fields from the table: "block"
	"""
	block_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_block_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_block_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_block_bool_exp
	): archive_block_aggregate!

	"""
	fetch data from the table: "block" using primary key columns
	"""
	block_by_pk(id: bpchar!): archive_block

	"""
	fetch data from the table: "call"
	"""
	call(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_call_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_call_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_call_bool_exp
	): [archive_call!]!

	"""
	fetch aggregated fields from the table: "call"
	"""
	call_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_call_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_call_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_call_bool_exp
	): archive_call_aggregate!

	"""
	fetch data from the table: "call" using primary key columns
	"""
	call_by_pk(id: String!): archive_call

	"""
	fetch data from the table: "contracts_contract_emitted"
	"""
	contracts_contract_emitted(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_contracts_contract_emitted_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_contracts_contract_emitted_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_contracts_contract_emitted_bool_exp
	): [archive_contracts_contract_emitted!]!

	"""
	fetch aggregated fields from the table: "contracts_contract_emitted"
	"""
	contracts_contract_emitted_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_contracts_contract_emitted_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_contracts_contract_emitted_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_contracts_contract_emitted_bool_exp
	): archive_contracts_contract_emitted_aggregate!

	"""
	fetch data from the table: "contracts_contract_emitted" using primary key columns
	"""
	contracts_contract_emitted_by_pk(
		event_id: bpchar!
	): archive_contracts_contract_emitted

	"""
	fetch data from the table: "event"
	"""
	event(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_event_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_event_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_event_bool_exp
	): [archive_event!]!

	"""
	fetch aggregated fields from the table: "event"
	"""
	event_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_event_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_event_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_event_bool_exp
	): archive_event_aggregate!

	"""
	fetch data from the table: "event" using primary key columns
	"""
	event_by_pk(id: bpchar!): archive_event

	"""
	fetch data from the table: "extrinsic"
	"""
	extrinsic(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_extrinsic_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_extrinsic_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_extrinsic_bool_exp
	): [archive_extrinsic!]!

	"""
	fetch aggregated fields from the table: "extrinsic"
	"""
	extrinsic_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_extrinsic_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_extrinsic_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_extrinsic_bool_exp
	): archive_extrinsic_aggregate!

	"""
	fetch data from the table: "extrinsic" using primary key columns
	"""
	extrinsic_by_pk(id: bpchar!): archive_extrinsic

	"""
	fetch data from the table: "frontier_ethereum_transaction"
	"""
	frontier_ethereum_transaction(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_frontier_ethereum_transaction_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_frontier_ethereum_transaction_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_frontier_ethereum_transaction_bool_exp
	): [archive_frontier_ethereum_transaction!]!

	"""
	fetch aggregated fields from the table: "frontier_ethereum_transaction"
	"""
	frontier_ethereum_transaction_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_frontier_ethereum_transaction_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_frontier_ethereum_transaction_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_frontier_ethereum_transaction_bool_exp
	): archive_frontier_ethereum_transaction_aggregate!

	"""
	fetch data from the table: "frontier_ethereum_transaction" using primary key columns
	"""
	frontier_ethereum_transaction_by_pk(
		call_id: String!
	): archive_frontier_ethereum_transaction

	"""
	fetch data from the table: "frontier_evm_log"
	"""
	frontier_evm_log(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_frontier_evm_log_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_frontier_evm_log_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_frontier_evm_log_bool_exp
	): [archive_frontier_evm_log!]!

	"""
	fetch aggregated fields from the table: "frontier_evm_log"
	"""
	frontier_evm_log_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_frontier_evm_log_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_frontier_evm_log_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_frontier_evm_log_bool_exp
	): archive_frontier_evm_log_aggregate!

	"""
	fetch data from the table: "frontier_evm_log" using primary key columns
	"""
	frontier_evm_log_by_pk(event_id: bpchar!): archive_frontier_evm_log

	"""
	fetch data from the table: "metadata"
	"""
	metadata(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_metadata_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_metadata_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_metadata_bool_exp
	): [archive_metadata!]!

	"""
	fetch aggregated fields from the table: "metadata"
	"""
	metadata_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_metadata_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_metadata_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_metadata_bool_exp
	): archive_metadata_aggregate!

	"""
	fetch data from the table: "metadata" using primary key columns
	"""
	metadata_by_pk(id: String!): archive_metadata
}

type archive_archive_subscription {
	"""
	fetch data from the table: "block"
	"""
	block(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_block_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_block_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_block_bool_exp
	): [archive_block!]!

	"""
	fetch aggregated fields from the table: "block"
	"""
	block_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_block_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_block_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_block_bool_exp
	): archive_block_aggregate!

	"""
	fetch data from the table: "block" using primary key columns
	"""
	block_by_pk(id: bpchar!): archive_block

	"""
	fetch data from the table in a streaming manner : "block"
	"""
	block_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!

		"""
		cursor to stream the results returned by the query
		"""
		cursor: [archive_block_stream_cursor_input]!

		"""
		filter the rows returned
		"""
		where: archive_block_bool_exp
	): [archive_block!]!

	"""
	fetch data from the table: "call"
	"""
	call(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_call_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_call_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_call_bool_exp
	): [archive_call!]!

	"""
	fetch aggregated fields from the table: "call"
	"""
	call_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_call_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_call_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_call_bool_exp
	): archive_call_aggregate!

	"""
	fetch data from the table: "call" using primary key columns
	"""
	call_by_pk(id: String!): archive_call

	"""
	fetch data from the table in a streaming manner : "call"
	"""
	call_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!

		"""
		cursor to stream the results returned by the query
		"""
		cursor: [archive_call_stream_cursor_input]!

		"""
		filter the rows returned
		"""
		where: archive_call_bool_exp
	): [archive_call!]!

	"""
	fetch data from the table: "contracts_contract_emitted"
	"""
	contracts_contract_emitted(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_contracts_contract_emitted_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_contracts_contract_emitted_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_contracts_contract_emitted_bool_exp
	): [archive_contracts_contract_emitted!]!

	"""
	fetch aggregated fields from the table: "contracts_contract_emitted"
	"""
	contracts_contract_emitted_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_contracts_contract_emitted_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_contracts_contract_emitted_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_contracts_contract_emitted_bool_exp
	): archive_contracts_contract_emitted_aggregate!

	"""
	fetch data from the table: "contracts_contract_emitted" using primary key columns
	"""
	contracts_contract_emitted_by_pk(
		event_id: bpchar!
	): archive_contracts_contract_emitted

	"""
	fetch data from the table in a streaming manner : "contracts_contract_emitted"
	"""
	contracts_contract_emitted_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!

		"""
		cursor to stream the results returned by the query
		"""
		cursor: [archive_contracts_contract_emitted_stream_cursor_input]!

		"""
		filter the rows returned
		"""
		where: archive_contracts_contract_emitted_bool_exp
	): [archive_contracts_contract_emitted!]!

	"""
	fetch data from the table: "event"
	"""
	event(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_event_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_event_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_event_bool_exp
	): [archive_event!]!

	"""
	fetch aggregated fields from the table: "event"
	"""
	event_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_event_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_event_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_event_bool_exp
	): archive_event_aggregate!

	"""
	fetch data from the table: "event" using primary key columns
	"""
	event_by_pk(id: bpchar!): archive_event

	"""
	fetch data from the table in a streaming manner : "event"
	"""
	event_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!

		"""
		cursor to stream the results returned by the query
		"""
		cursor: [archive_event_stream_cursor_input]!

		"""
		filter the rows returned
		"""
		where: archive_event_bool_exp
	): [archive_event!]!

	"""
	fetch data from the table: "extrinsic"
	"""
	extrinsic(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_extrinsic_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_extrinsic_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_extrinsic_bool_exp
	): [archive_extrinsic!]!

	"""
	fetch aggregated fields from the table: "extrinsic"
	"""
	extrinsic_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_extrinsic_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_extrinsic_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_extrinsic_bool_exp
	): archive_extrinsic_aggregate!

	"""
	fetch data from the table: "extrinsic" using primary key columns
	"""
	extrinsic_by_pk(id: bpchar!): archive_extrinsic

	"""
	fetch data from the table in a streaming manner : "extrinsic"
	"""
	extrinsic_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!

		"""
		cursor to stream the results returned by the query
		"""
		cursor: [archive_extrinsic_stream_cursor_input]!

		"""
		filter the rows returned
		"""
		where: archive_extrinsic_bool_exp
	): [archive_extrinsic!]!

	"""
	fetch data from the table: "frontier_ethereum_transaction"
	"""
	frontier_ethereum_transaction(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_frontier_ethereum_transaction_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_frontier_ethereum_transaction_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_frontier_ethereum_transaction_bool_exp
	): [archive_frontier_ethereum_transaction!]!

	"""
	fetch aggregated fields from the table: "frontier_ethereum_transaction"
	"""
	frontier_ethereum_transaction_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_frontier_ethereum_transaction_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_frontier_ethereum_transaction_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_frontier_ethereum_transaction_bool_exp
	): archive_frontier_ethereum_transaction_aggregate!

	"""
	fetch data from the table: "frontier_ethereum_transaction" using primary key columns
	"""
	frontier_ethereum_transaction_by_pk(
		call_id: String!
	): archive_frontier_ethereum_transaction

	"""
	fetch data from the table in a streaming manner : "frontier_ethereum_transaction"
	"""
	frontier_ethereum_transaction_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!

		"""
		cursor to stream the results returned by the query
		"""
		cursor: [archive_frontier_ethereum_transaction_stream_cursor_input]!

		"""
		filter the rows returned
		"""
		where: archive_frontier_ethereum_transaction_bool_exp
	): [archive_frontier_ethereum_transaction!]!

	"""
	fetch data from the table: "frontier_evm_log"
	"""
	frontier_evm_log(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_frontier_evm_log_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_frontier_evm_log_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_frontier_evm_log_bool_exp
	): [archive_frontier_evm_log!]!

	"""
	fetch aggregated fields from the table: "frontier_evm_log"
	"""
	frontier_evm_log_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_frontier_evm_log_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_frontier_evm_log_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_frontier_evm_log_bool_exp
	): archive_frontier_evm_log_aggregate!

	"""
	fetch data from the table: "frontier_evm_log" using primary key columns
	"""
	frontier_evm_log_by_pk(event_id: bpchar!): archive_frontier_evm_log

	"""
	fetch data from the table in a streaming manner : "frontier_evm_log"
	"""
	frontier_evm_log_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!

		"""
		cursor to stream the results returned by the query
		"""
		cursor: [archive_frontier_evm_log_stream_cursor_input]!

		"""
		filter the rows returned
		"""
		where: archive_frontier_evm_log_bool_exp
	): [archive_frontier_evm_log!]!

	"""
	fetch data from the table: "metadata"
	"""
	metadata(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_metadata_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_metadata_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_metadata_bool_exp
	): [archive_metadata!]!

	"""
	fetch aggregated fields from the table: "metadata"
	"""
	metadata_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_metadata_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_metadata_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_metadata_bool_exp
	): archive_metadata_aggregate!

	"""
	fetch data from the table: "metadata" using primary key columns
	"""
	metadata_by_pk(id: String!): archive_metadata

	"""
	fetch data from the table in a streaming manner : "metadata"
	"""
	metadata_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!

		"""
		cursor to stream the results returned by the query
		"""
		cursor: [archive_metadata_stream_cursor_input]!

		"""
		filter the rows returned
		"""
		where: archive_metadata_bool_exp
	): [archive_metadata!]!
}

"""
columns and relationships of "block"
"""
type archive_block {
	"""
	An array relationship
	"""
	calls(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_call_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_call_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_call_bool_exp
	): [archive_call!]!

	"""
	An aggregate relationship
	"""
	calls_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_call_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_call_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_call_bool_exp
	): archive_call_aggregate!

	"""
	An array relationship
	"""
	events(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_event_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_event_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_event_bool_exp
	): [archive_event!]!

	"""
	An aggregate relationship
	"""
	events_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_event_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_event_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_event_bool_exp
	): archive_event_aggregate!

	"""
	An array relationship
	"""
	extrinsics(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_extrinsic_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_extrinsic_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_extrinsic_bool_exp
	): [archive_extrinsic!]!

	"""
	An aggregate relationship
	"""
	extrinsics_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_extrinsic_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_extrinsic_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_extrinsic_bool_exp
	): archive_extrinsic_aggregate!
	extrinsics_root: bpchar!
	hash: bpchar!
	height: Int!
	id: bpchar!
	parent_hash: bpchar!
	spec_id: String!
	state_root: bpchar!
	timestamp: timestamptz!
	validator: String
}

"""
aggregated selection of "block"
"""
type archive_block_aggregate {
	aggregate: archive_block_aggregate_fields
	nodes: [archive_block!]!
}

"""
aggregate fields of "block"
"""
type archive_block_aggregate_fields {
	avg: archive_block_avg_fields
	count(columns: [archive_block_select_column!], distinct: Boolean): Int!
	max: archive_block_max_fields
	min: archive_block_min_fields
	stddev: archive_block_stddev_fields
	stddev_pop: archive_block_stddev_pop_fields
	stddev_samp: archive_block_stddev_samp_fields
	sum: archive_block_sum_fields
	var_pop: archive_block_var_pop_fields
	var_samp: archive_block_var_samp_fields
	variance: archive_block_variance_fields
}

"""
aggregate avg on columns
"""
type archive_block_avg_fields {
	height: Float
}

"""
Boolean expression to filter rows from the table "block". All fields are combined with a logical 'AND'.
"""
input archive_block_bool_exp {
	_and: [archive_block_bool_exp!]
	_not: archive_block_bool_exp
	_or: [archive_block_bool_exp!]
	calls: archive_call_bool_exp
	events: archive_event_bool_exp
	extrinsics: archive_extrinsic_bool_exp
	extrinsics_root: bpchar_comparison_exp
	hash: bpchar_comparison_exp
	height: Int_comparison_exp
	id: bpchar_comparison_exp
	parent_hash: bpchar_comparison_exp
	spec_id: String_comparison_exp
	state_root: bpchar_comparison_exp
	timestamp: timestamptz_comparison_exp
	validator: String_comparison_exp
}

"""
unique or primary key constraints on table "block"
"""
enum archive_block_constraint {
	"""
	unique or primary key constraint on columns "id"
	"""
	block_pkey
}

"""
input type for incrementing numeric columns in table "block"
"""
input archive_block_inc_input {
	height: Int
}

"""
input type for inserting data into table "block"
"""
input archive_block_insert_input {
	calls: archive_call_arr_rel_insert_input
	events: archive_event_arr_rel_insert_input
	extrinsics: archive_extrinsic_arr_rel_insert_input
	extrinsics_root: bpchar
	hash: bpchar
	height: Int
	id: bpchar
	parent_hash: bpchar
	spec_id: String
	state_root: bpchar
	timestamp: timestamptz
	validator: String
}

"""
aggregate max on columns
"""
type archive_block_max_fields {
	extrinsics_root: bpchar
	hash: bpchar
	height: Int
	id: bpchar
	parent_hash: bpchar
	spec_id: String
	state_root: bpchar
	timestamp: timestamptz
	validator: String
}

"""
aggregate min on columns
"""
type archive_block_min_fields {
	extrinsics_root: bpchar
	hash: bpchar
	height: Int
	id: bpchar
	parent_hash: bpchar
	spec_id: String
	state_root: bpchar
	timestamp: timestamptz
	validator: String
}

"""
response of any mutation on the table "block"
"""
type archive_block_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!

	"""
	data from the rows affected by the mutation
	"""
	returning: [archive_block!]!
}

"""
input type for inserting object relation for remote table "block"
"""
input archive_block_obj_rel_insert_input {
	data: archive_block_insert_input!

	"""
	upsert condition
	"""
	on_conflict: archive_block_on_conflict
}

"""
on_conflict condition type for table "block"
"""
input archive_block_on_conflict {
	constraint: archive_block_constraint!
	update_columns: [archive_block_update_column!]! = []
	where: archive_block_bool_exp
}

"""
Ordering options when selecting data from "block".
"""
input archive_block_order_by {
	calls_aggregate: archive_call_aggregate_order_by
	events_aggregate: archive_event_aggregate_order_by
	extrinsics_aggregate: archive_extrinsic_aggregate_order_by
	extrinsics_root: order_by
	hash: order_by
	height: order_by
	id: order_by
	parent_hash: order_by
	spec_id: order_by
	state_root: order_by
	timestamp: order_by
	validator: order_by
}

"""
primary key columns input for table: block
"""
input archive_block_pk_columns_input {
	id: bpchar!
}

"""
select columns of table "block"
"""
enum archive_block_select_column {
	"""
	column name
	"""
	extrinsics_root

	"""
	column name
	"""
	hash

	"""
	column name
	"""
	height

	"""
	column name
	"""
	id

	"""
	column name
	"""
	parent_hash

	"""
	column name
	"""
	spec_id

	"""
	column name
	"""
	state_root

	"""
	column name
	"""
	timestamp

	"""
	column name
	"""
	validator
}

"""
input type for updating data in table "block"
"""
input archive_block_set_input {
	extrinsics_root: bpchar
	hash: bpchar
	height: Int
	id: bpchar
	parent_hash: bpchar
	spec_id: String
	state_root: bpchar
	timestamp: timestamptz
	validator: String
}

"""
aggregate stddev on columns
"""
type archive_block_stddev_fields {
	height: Float
}

"""
aggregate stddev_pop on columns
"""
type archive_block_stddev_pop_fields {
	height: Float
}

"""
aggregate stddev_samp on columns
"""
type archive_block_stddev_samp_fields {
	height: Float
}

"""
Streaming cursor of the table "block"
"""
input archive_block_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: archive_block_stream_cursor_value_input!

	"""
	cursor ordering
	"""
	ordering: archive_cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input archive_block_stream_cursor_value_input {
	extrinsics_root: bpchar
	hash: bpchar
	height: Int
	id: bpchar
	parent_hash: bpchar
	spec_id: String
	state_root: bpchar
	timestamp: timestamptz
	validator: String
}

"""
aggregate sum on columns
"""
type archive_block_sum_fields {
	height: Int
}

"""
update columns of table "block"
"""
enum archive_block_update_column {
	"""
	column name
	"""
	extrinsics_root

	"""
	column name
	"""
	hash

	"""
	column name
	"""
	height

	"""
	column name
	"""
	id

	"""
	column name
	"""
	parent_hash

	"""
	column name
	"""
	spec_id

	"""
	column name
	"""
	state_root

	"""
	column name
	"""
	timestamp

	"""
	column name
	"""
	validator
}

input archive_block_updates {
	"""
	increments the numeric columns with given value of the filtered values
	"""
	_inc: archive_block_inc_input

	"""
	sets the columns of the filtered rows to the given values
	"""
	_set: archive_block_set_input
	where: archive_block_bool_exp!
}

"""
aggregate var_pop on columns
"""
type archive_block_var_pop_fields {
	height: Float
}

"""
aggregate var_samp on columns
"""
type archive_block_var_samp_fields {
	height: Float
}

"""
aggregate variance on columns
"""
type archive_block_variance_fields {
	height: Float
}

"""
columns and relationships of "call"
"""
type archive_call {
	args(
		"""
		JSON select path
		"""
		path: String
	): jsonb

	"""
	An object relationship
	"""
	block: archive_block!
	block_id: bpchar!

	"""
	An object relationship
	"""
	call: archive_call

	"""
	An array relationship
	"""
	calls(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_call_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_call_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_call_bool_exp
	): [archive_call!]!

	"""
	An aggregate relationship
	"""
	calls_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_call_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_call_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_call_bool_exp
	): archive_call_aggregate!
	error(
		"""
		JSON select path
		"""
		path: String
	): jsonb

	"""
	An array relationship
	"""
	events(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_event_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_event_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_event_bool_exp
	): [archive_event!]!

	"""
	An aggregate relationship
	"""
	events_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_event_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_event_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_event_bool_exp
	): archive_event_aggregate!

	"""
	An object relationship
	"""
	extrinsic: archive_extrinsic!
	extrinsic_id: bpchar!

	"""
	An array relationship
	"""
	frontier_ethereum_transactions(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_frontier_ethereum_transaction_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_frontier_ethereum_transaction_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_frontier_ethereum_transaction_bool_exp
	): [archive_frontier_ethereum_transaction!]!

	"""
	An aggregate relationship
	"""
	frontier_ethereum_transactions_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_frontier_ethereum_transaction_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_frontier_ethereum_transaction_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_frontier_ethereum_transaction_bool_exp
	): archive_frontier_ethereum_transaction_aggregate!
	id: String!
	name: String!
	origin(
		"""
		JSON select path
		"""
		path: String
	): jsonb
	parent_id: String
	pos: Int!
	success: Boolean!
}

"""
aggregated selection of "call"
"""
type archive_call_aggregate {
	aggregate: archive_call_aggregate_fields
	nodes: [archive_call!]!
}

"""
aggregate fields of "call"
"""
type archive_call_aggregate_fields {
	avg: archive_call_avg_fields
	count(columns: [archive_call_select_column!], distinct: Boolean): Int!
	max: archive_call_max_fields
	min: archive_call_min_fields
	stddev: archive_call_stddev_fields
	stddev_pop: archive_call_stddev_pop_fields
	stddev_samp: archive_call_stddev_samp_fields
	sum: archive_call_sum_fields
	var_pop: archive_call_var_pop_fields
	var_samp: archive_call_var_samp_fields
	variance: archive_call_variance_fields
}

"""
order by aggregate values of table "call"
"""
input archive_call_aggregate_order_by {
	avg: archive_call_avg_order_by
	count: order_by
	max: archive_call_max_order_by
	min: archive_call_min_order_by
	stddev: archive_call_stddev_order_by
	stddev_pop: archive_call_stddev_pop_order_by
	stddev_samp: archive_call_stddev_samp_order_by
	sum: archive_call_sum_order_by
	var_pop: archive_call_var_pop_order_by
	var_samp: archive_call_var_samp_order_by
	variance: archive_call_variance_order_by
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input archive_call_append_input {
	args: jsonb
	error: jsonb
	origin: jsonb
}

"""
input type for inserting array relation for remote table "call"
"""
input archive_call_arr_rel_insert_input {
	data: [archive_call_insert_input!]!

	"""
	upsert condition
	"""
	on_conflict: archive_call_on_conflict
}

"""
aggregate avg on columns
"""
type archive_call_avg_fields {
	pos: Float
}

"""
order by avg() on columns of table "call"
"""
input archive_call_avg_order_by {
	pos: order_by
}

"""
Boolean expression to filter rows from the table "call". All fields are combined with a logical 'AND'.
"""
input archive_call_bool_exp {
	_and: [archive_call_bool_exp!]
	_not: archive_call_bool_exp
	_or: [archive_call_bool_exp!]
	args: jsonb_comparison_exp
	block: archive_block_bool_exp
	block_id: bpchar_comparison_exp
	call: archive_call_bool_exp
	calls: archive_call_bool_exp
	error: jsonb_comparison_exp
	events: archive_event_bool_exp
	extrinsic: archive_extrinsic_bool_exp
	extrinsic_id: bpchar_comparison_exp
	frontier_ethereum_transactions: archive_frontier_ethereum_transaction_bool_exp
	id: String_comparison_exp
	name: String_comparison_exp
	origin: jsonb_comparison_exp
	parent_id: String_comparison_exp
	pos: Int_comparison_exp
	success: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "call"
"""
enum archive_call_constraint {
	"""
	unique or primary key constraint on columns "id"
	"""
	call_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input archive_call_delete_at_path_input {
	args: [String!]
	error: [String!]
	origin: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input archive_call_delete_elem_input {
	args: Int
	error: Int
	origin: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input archive_call_delete_key_input {
	args: String
	error: String
	origin: String
}

"""
input type for incrementing numeric columns in table "call"
"""
input archive_call_inc_input {
	pos: Int
}

"""
input type for inserting data into table "call"
"""
input archive_call_insert_input {
	args: jsonb
	block: archive_block_obj_rel_insert_input
	block_id: bpchar
	call: archive_call_obj_rel_insert_input
	calls: archive_call_arr_rel_insert_input
	error: jsonb
	events: archive_event_arr_rel_insert_input
	extrinsic: archive_extrinsic_obj_rel_insert_input
	extrinsic_id: bpchar
	frontier_ethereum_transactions: archive_frontier_ethereum_transaction_arr_rel_insert_input
	id: String
	name: String
	origin: jsonb
	parent_id: String
	pos: Int
	success: Boolean
}

"""
aggregate max on columns
"""
type archive_call_max_fields {
	block_id: bpchar
	extrinsic_id: bpchar
	id: String
	name: String
	parent_id: String
	pos: Int
}

"""
order by max() on columns of table "call"
"""
input archive_call_max_order_by {
	block_id: order_by
	extrinsic_id: order_by
	id: order_by
	name: order_by
	parent_id: order_by
	pos: order_by
}

"""
aggregate min on columns
"""
type archive_call_min_fields {
	block_id: bpchar
	extrinsic_id: bpchar
	id: String
	name: String
	parent_id: String
	pos: Int
}

"""
order by min() on columns of table "call"
"""
input archive_call_min_order_by {
	block_id: order_by
	extrinsic_id: order_by
	id: order_by
	name: order_by
	parent_id: order_by
	pos: order_by
}

"""
response of any mutation on the table "call"
"""
type archive_call_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!

	"""
	data from the rows affected by the mutation
	"""
	returning: [archive_call!]!
}

"""
input type for inserting object relation for remote table "call"
"""
input archive_call_obj_rel_insert_input {
	data: archive_call_insert_input!

	"""
	upsert condition
	"""
	on_conflict: archive_call_on_conflict
}

"""
on_conflict condition type for table "call"
"""
input archive_call_on_conflict {
	constraint: archive_call_constraint!
	update_columns: [archive_call_update_column!]! = []
	where: archive_call_bool_exp
}

"""
Ordering options when selecting data from "call".
"""
input archive_call_order_by {
	args: order_by
	block: archive_block_order_by
	block_id: order_by
	call: archive_call_order_by
	calls_aggregate: archive_call_aggregate_order_by
	error: order_by
	events_aggregate: archive_event_aggregate_order_by
	extrinsic: archive_extrinsic_order_by
	extrinsic_id: order_by
	frontier_ethereum_transactions_aggregate: archive_frontier_ethereum_transaction_aggregate_order_by
	id: order_by
	name: order_by
	origin: order_by
	parent_id: order_by
	pos: order_by
	success: order_by
}

"""
primary key columns input for table: call
"""
input archive_call_pk_columns_input {
	id: String!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input archive_call_prepend_input {
	args: jsonb
	error: jsonb
	origin: jsonb
}

"""
select columns of table "call"
"""
enum archive_call_select_column {
	"""
	column name
	"""
	args

	"""
	column name
	"""
	block_id

	"""
	column name
	"""
	error

	"""
	column name
	"""
	extrinsic_id

	"""
	column name
	"""
	id

	"""
	column name
	"""
	name

	"""
	column name
	"""
	origin

	"""
	column name
	"""
	parent_id

	"""
	column name
	"""
	pos

	"""
	column name
	"""
	success
}

"""
input type for updating data in table "call"
"""
input archive_call_set_input {
	args: jsonb
	block_id: bpchar
	error: jsonb
	extrinsic_id: bpchar
	id: String
	name: String
	origin: jsonb
	parent_id: String
	pos: Int
	success: Boolean
}

"""
aggregate stddev on columns
"""
type archive_call_stddev_fields {
	pos: Float
}

"""
order by stddev() on columns of table "call"
"""
input archive_call_stddev_order_by {
	pos: order_by
}

"""
aggregate stddev_pop on columns
"""
type archive_call_stddev_pop_fields {
	pos: Float
}

"""
order by stddev_pop() on columns of table "call"
"""
input archive_call_stddev_pop_order_by {
	pos: order_by
}

"""
aggregate stddev_samp on columns
"""
type archive_call_stddev_samp_fields {
	pos: Float
}

"""
order by stddev_samp() on columns of table "call"
"""
input archive_call_stddev_samp_order_by {
	pos: order_by
}

"""
Streaming cursor of the table "call"
"""
input archive_call_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: archive_call_stream_cursor_value_input!

	"""
	cursor ordering
	"""
	ordering: archive_cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input archive_call_stream_cursor_value_input {
	args: jsonb
	block_id: bpchar
	error: jsonb
	extrinsic_id: bpchar
	id: String
	name: String
	origin: jsonb
	parent_id: String
	pos: Int
	success: Boolean
}

"""
aggregate sum on columns
"""
type archive_call_sum_fields {
	pos: Int
}

"""
order by sum() on columns of table "call"
"""
input archive_call_sum_order_by {
	pos: order_by
}

"""
update columns of table "call"
"""
enum archive_call_update_column {
	"""
	column name
	"""
	args

	"""
	column name
	"""
	block_id

	"""
	column name
	"""
	error

	"""
	column name
	"""
	extrinsic_id

	"""
	column name
	"""
	id

	"""
	column name
	"""
	name

	"""
	column name
	"""
	origin

	"""
	column name
	"""
	parent_id

	"""
	column name
	"""
	pos

	"""
	column name
	"""
	success
}

input archive_call_updates {
	"""
	append existing jsonb value of filtered columns with new jsonb value
	"""
	_append: archive_call_append_input

	"""
	delete the field or element with specified path (for JSON arrays, negative integers count from the end)
	"""
	_delete_at_path: archive_call_delete_at_path_input

	"""
	delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
	"""
	_delete_elem: archive_call_delete_elem_input

	"""
	delete key/value pair or string element. key/value pairs are matched based on their key value
	"""
	_delete_key: archive_call_delete_key_input

	"""
	increments the numeric columns with given value of the filtered values
	"""
	_inc: archive_call_inc_input

	"""
	prepend existing jsonb value of filtered columns with new jsonb value
	"""
	_prepend: archive_call_prepend_input

	"""
	sets the columns of the filtered rows to the given values
	"""
	_set: archive_call_set_input
	where: archive_call_bool_exp!
}

"""
aggregate var_pop on columns
"""
type archive_call_var_pop_fields {
	pos: Float
}

"""
order by var_pop() on columns of table "call"
"""
input archive_call_var_pop_order_by {
	pos: order_by
}

"""
aggregate var_samp on columns
"""
type archive_call_var_samp_fields {
	pos: Float
}

"""
order by var_samp() on columns of table "call"
"""
input archive_call_var_samp_order_by {
	pos: order_by
}

"""
aggregate variance on columns
"""
type archive_call_variance_fields {
	pos: Float
}

"""
order by variance() on columns of table "call"
"""
input archive_call_variance_order_by {
	pos: order_by
}

"""
columns and relationships of "contracts_contract_emitted"
"""
type archive_contracts_contract_emitted {
	contract: String!

	"""
	An object relationship
	"""
	event: archive_event!
	event_id: bpchar!
}

"""
aggregated selection of "contracts_contract_emitted"
"""
type archive_contracts_contract_emitted_aggregate {
	aggregate: archive_contracts_contract_emitted_aggregate_fields
	nodes: [archive_contracts_contract_emitted!]!
}

"""
aggregate fields of "contracts_contract_emitted"
"""
type archive_contracts_contract_emitted_aggregate_fields {
	count(
		columns: [archive_contracts_contract_emitted_select_column!]
		distinct: Boolean
	): Int!
	max: archive_contracts_contract_emitted_max_fields
	min: archive_contracts_contract_emitted_min_fields
}

"""
order by aggregate values of table "contracts_contract_emitted"
"""
input archive_contracts_contract_emitted_aggregate_order_by {
	count: order_by
	max: archive_contracts_contract_emitted_max_order_by
	min: archive_contracts_contract_emitted_min_order_by
}

"""
input type for inserting array relation for remote table "contracts_contract_emitted"
"""
input archive_contracts_contract_emitted_arr_rel_insert_input {
	data: [archive_contracts_contract_emitted_insert_input!]!

	"""
	upsert condition
	"""
	on_conflict: archive_contracts_contract_emitted_on_conflict
}

"""
Boolean expression to filter rows from the table "contracts_contract_emitted". All fields are combined with a logical 'AND'.
"""
input archive_contracts_contract_emitted_bool_exp {
	_and: [archive_contracts_contract_emitted_bool_exp!]
	_not: archive_contracts_contract_emitted_bool_exp
	_or: [archive_contracts_contract_emitted_bool_exp!]
	contract: String_comparison_exp
	event: archive_event_bool_exp
	event_id: bpchar_comparison_exp
}

"""
unique or primary key constraints on table "contracts_contract_emitted"
"""
enum archive_contracts_contract_emitted_constraint {
	"""
	unique or primary key constraint on columns "event_id"
	"""
	contracts_contract_emitted_pkey
}

"""
input type for inserting data into table "contracts_contract_emitted"
"""
input archive_contracts_contract_emitted_insert_input {
	contract: String
	event: archive_event_obj_rel_insert_input
	event_id: bpchar
}

"""
aggregate max on columns
"""
type archive_contracts_contract_emitted_max_fields {
	contract: String
	event_id: bpchar
}

"""
order by max() on columns of table "contracts_contract_emitted"
"""
input archive_contracts_contract_emitted_max_order_by {
	contract: order_by
	event_id: order_by
}

"""
aggregate min on columns
"""
type archive_contracts_contract_emitted_min_fields {
	contract: String
	event_id: bpchar
}

"""
order by min() on columns of table "contracts_contract_emitted"
"""
input archive_contracts_contract_emitted_min_order_by {
	contract: order_by
	event_id: order_by
}

"""
response of any mutation on the table "contracts_contract_emitted"
"""
type archive_contracts_contract_emitted_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!

	"""
	data from the rows affected by the mutation
	"""
	returning: [archive_contracts_contract_emitted!]!
}

"""
on_conflict condition type for table "contracts_contract_emitted"
"""
input archive_contracts_contract_emitted_on_conflict {
	constraint: archive_contracts_contract_emitted_constraint!
	update_columns: [archive_contracts_contract_emitted_update_column!]! = []
	where: archive_contracts_contract_emitted_bool_exp
}

"""
Ordering options when selecting data from "contracts_contract_emitted".
"""
input archive_contracts_contract_emitted_order_by {
	contract: order_by
	event: archive_event_order_by
	event_id: order_by
}

"""
primary key columns input for table: contracts_contract_emitted
"""
input archive_contracts_contract_emitted_pk_columns_input {
	event_id: bpchar!
}

"""
select columns of table "contracts_contract_emitted"
"""
enum archive_contracts_contract_emitted_select_column {
	"""
	column name
	"""
	contract

	"""
	column name
	"""
	event_id
}

"""
input type for updating data in table "contracts_contract_emitted"
"""
input archive_contracts_contract_emitted_set_input {
	contract: String
	event_id: bpchar
}

"""
Streaming cursor of the table "contracts_contract_emitted"
"""
input archive_contracts_contract_emitted_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: archive_contracts_contract_emitted_stream_cursor_value_input!

	"""
	cursor ordering
	"""
	ordering: archive_cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input archive_contracts_contract_emitted_stream_cursor_value_input {
	contract: String
	event_id: bpchar
}

"""
update columns of table "contracts_contract_emitted"
"""
enum archive_contracts_contract_emitted_update_column {
	"""
	column name
	"""
	contract

	"""
	column name
	"""
	event_id
}

input archive_contracts_contract_emitted_updates {
	"""
	sets the columns of the filtered rows to the given values
	"""
	_set: archive_contracts_contract_emitted_set_input
	where: archive_contracts_contract_emitted_bool_exp!
}

"""
ordering argument of a cursor
"""
enum archive_cursor_ordering {
	"""
	ascending ordering of the cursor
	"""
	ASC

	"""
	descending ordering of the cursor
	"""
	DESC
}

"""
columns and relationships of "event"
"""
type archive_event {
	args(
		"""
		JSON select path
		"""
		path: String
	): jsonb

	"""
	An object relationship
	"""
	block: archive_block!
	block_id: bpchar!

	"""
	An object relationship
	"""
	call: archive_call
	call_id: String

	"""
	An array relationship
	"""
	contracts_contract_emitteds(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_contracts_contract_emitted_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_contracts_contract_emitted_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_contracts_contract_emitted_bool_exp
	): [archive_contracts_contract_emitted!]!

	"""
	An aggregate relationship
	"""
	contracts_contract_emitteds_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_contracts_contract_emitted_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_contracts_contract_emitted_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_contracts_contract_emitted_bool_exp
	): archive_contracts_contract_emitted_aggregate!

	"""
	An object relationship
	"""
	extrinsic: archive_extrinsic
	extrinsic_id: bpchar

	"""
	An array relationship
	"""
	frontier_evm_logs(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_frontier_evm_log_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_frontier_evm_log_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_frontier_evm_log_bool_exp
	): [archive_frontier_evm_log!]!

	"""
	An aggregate relationship
	"""
	frontier_evm_logs_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_frontier_evm_log_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_frontier_evm_log_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_frontier_evm_log_bool_exp
	): archive_frontier_evm_log_aggregate!
	id: bpchar!
	index_in_block: Int!
	name: String!
	phase: String!
	pos: Int!
}

"""
aggregated selection of "event"
"""
type archive_event_aggregate {
	aggregate: archive_event_aggregate_fields
	nodes: [archive_event!]!
}

"""
aggregate fields of "event"
"""
type archive_event_aggregate_fields {
	avg: archive_event_avg_fields
	count(columns: [archive_event_select_column!], distinct: Boolean): Int!
	max: archive_event_max_fields
	min: archive_event_min_fields
	stddev: archive_event_stddev_fields
	stddev_pop: archive_event_stddev_pop_fields
	stddev_samp: archive_event_stddev_samp_fields
	sum: archive_event_sum_fields
	var_pop: archive_event_var_pop_fields
	var_samp: archive_event_var_samp_fields
	variance: archive_event_variance_fields
}

"""
order by aggregate values of table "event"
"""
input archive_event_aggregate_order_by {
	avg: archive_event_avg_order_by
	count: order_by
	max: archive_event_max_order_by
	min: archive_event_min_order_by
	stddev: archive_event_stddev_order_by
	stddev_pop: archive_event_stddev_pop_order_by
	stddev_samp: archive_event_stddev_samp_order_by
	sum: archive_event_sum_order_by
	var_pop: archive_event_var_pop_order_by
	var_samp: archive_event_var_samp_order_by
	variance: archive_event_variance_order_by
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input archive_event_append_input {
	args: jsonb
}

"""
input type for inserting array relation for remote table "event"
"""
input archive_event_arr_rel_insert_input {
	data: [archive_event_insert_input!]!

	"""
	upsert condition
	"""
	on_conflict: archive_event_on_conflict
}

"""
aggregate avg on columns
"""
type archive_event_avg_fields {
	index_in_block: Float
	pos: Float
}

"""
order by avg() on columns of table "event"
"""
input archive_event_avg_order_by {
	index_in_block: order_by
	pos: order_by
}

"""
Boolean expression to filter rows from the table "event". All fields are combined with a logical 'AND'.
"""
input archive_event_bool_exp {
	_and: [archive_event_bool_exp!]
	_not: archive_event_bool_exp
	_or: [archive_event_bool_exp!]
	args: jsonb_comparison_exp
	block: archive_block_bool_exp
	block_id: bpchar_comparison_exp
	call: archive_call_bool_exp
	call_id: String_comparison_exp
	contracts_contract_emitteds: archive_contracts_contract_emitted_bool_exp
	extrinsic: archive_extrinsic_bool_exp
	extrinsic_id: bpchar_comparison_exp
	frontier_evm_logs: archive_frontier_evm_log_bool_exp
	id: bpchar_comparison_exp
	index_in_block: Int_comparison_exp
	name: String_comparison_exp
	phase: String_comparison_exp
	pos: Int_comparison_exp
}

"""
unique or primary key constraints on table "event"
"""
enum archive_event_constraint {
	"""
	unique or primary key constraint on columns "id"
	"""
	event_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input archive_event_delete_at_path_input {
	args: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input archive_event_delete_elem_input {
	args: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input archive_event_delete_key_input {
	args: String
}

"""
input type for incrementing numeric columns in table "event"
"""
input archive_event_inc_input {
	index_in_block: Int
	pos: Int
}

"""
input type for inserting data into table "event"
"""
input archive_event_insert_input {
	args: jsonb
	block: archive_block_obj_rel_insert_input
	block_id: bpchar
	call: archive_call_obj_rel_insert_input
	call_id: String
	contracts_contract_emitteds: archive_contracts_contract_emitted_arr_rel_insert_input
	extrinsic: archive_extrinsic_obj_rel_insert_input
	extrinsic_id: bpchar
	frontier_evm_logs: archive_frontier_evm_log_arr_rel_insert_input
	id: bpchar
	index_in_block: Int
	name: String
	phase: String
	pos: Int
}

"""
aggregate max on columns
"""
type archive_event_max_fields {
	block_id: bpchar
	call_id: String
	extrinsic_id: bpchar
	id: bpchar
	index_in_block: Int
	name: String
	phase: String
	pos: Int
}

"""
order by max() on columns of table "event"
"""
input archive_event_max_order_by {
	block_id: order_by
	call_id: order_by
	extrinsic_id: order_by
	id: order_by
	index_in_block: order_by
	name: order_by
	phase: order_by
	pos: order_by
}

"""
aggregate min on columns
"""
type archive_event_min_fields {
	block_id: bpchar
	call_id: String
	extrinsic_id: bpchar
	id: bpchar
	index_in_block: Int
	name: String
	phase: String
	pos: Int
}

"""
order by min() on columns of table "event"
"""
input archive_event_min_order_by {
	block_id: order_by
	call_id: order_by
	extrinsic_id: order_by
	id: order_by
	index_in_block: order_by
	name: order_by
	phase: order_by
	pos: order_by
}

"""
response of any mutation on the table "event"
"""
type archive_event_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!

	"""
	data from the rows affected by the mutation
	"""
	returning: [archive_event!]!
}

"""
input type for inserting object relation for remote table "event"
"""
input archive_event_obj_rel_insert_input {
	data: archive_event_insert_input!

	"""
	upsert condition
	"""
	on_conflict: archive_event_on_conflict
}

"""
on_conflict condition type for table "event"
"""
input archive_event_on_conflict {
	constraint: archive_event_constraint!
	update_columns: [archive_event_update_column!]! = []
	where: archive_event_bool_exp
}

"""
Ordering options when selecting data from "event".
"""
input archive_event_order_by {
	args: order_by
	block: archive_block_order_by
	block_id: order_by
	call: archive_call_order_by
	call_id: order_by
	contracts_contract_emitteds_aggregate: archive_contracts_contract_emitted_aggregate_order_by
	extrinsic: archive_extrinsic_order_by
	extrinsic_id: order_by
	frontier_evm_logs_aggregate: archive_frontier_evm_log_aggregate_order_by
	id: order_by
	index_in_block: order_by
	name: order_by
	phase: order_by
	pos: order_by
}

"""
primary key columns input for table: event
"""
input archive_event_pk_columns_input {
	id: bpchar!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input archive_event_prepend_input {
	args: jsonb
}

"""
select columns of table "event"
"""
enum archive_event_select_column {
	"""
	column name
	"""
	args

	"""
	column name
	"""
	block_id

	"""
	column name
	"""
	call_id

	"""
	column name
	"""
	extrinsic_id

	"""
	column name
	"""
	id

	"""
	column name
	"""
	index_in_block

	"""
	column name
	"""
	name

	"""
	column name
	"""
	phase

	"""
	column name
	"""
	pos
}

"""
input type for updating data in table "event"
"""
input archive_event_set_input {
	args: jsonb
	block_id: bpchar
	call_id: String
	extrinsic_id: bpchar
	id: bpchar
	index_in_block: Int
	name: String
	phase: String
	pos: Int
}

"""
aggregate stddev on columns
"""
type archive_event_stddev_fields {
	index_in_block: Float
	pos: Float
}

"""
order by stddev() on columns of table "event"
"""
input archive_event_stddev_order_by {
	index_in_block: order_by
	pos: order_by
}

"""
aggregate stddev_pop on columns
"""
type archive_event_stddev_pop_fields {
	index_in_block: Float
	pos: Float
}

"""
order by stddev_pop() on columns of table "event"
"""
input archive_event_stddev_pop_order_by {
	index_in_block: order_by
	pos: order_by
}

"""
aggregate stddev_samp on columns
"""
type archive_event_stddev_samp_fields {
	index_in_block: Float
	pos: Float
}

"""
order by stddev_samp() on columns of table "event"
"""
input archive_event_stddev_samp_order_by {
	index_in_block: order_by
	pos: order_by
}

"""
Streaming cursor of the table "event"
"""
input archive_event_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: archive_event_stream_cursor_value_input!

	"""
	cursor ordering
	"""
	ordering: archive_cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input archive_event_stream_cursor_value_input {
	args: jsonb
	block_id: bpchar
	call_id: String
	extrinsic_id: bpchar
	id: bpchar
	index_in_block: Int
	name: String
	phase: String
	pos: Int
}

"""
aggregate sum on columns
"""
type archive_event_sum_fields {
	index_in_block: Int
	pos: Int
}

"""
order by sum() on columns of table "event"
"""
input archive_event_sum_order_by {
	index_in_block: order_by
	pos: order_by
}

"""
update columns of table "event"
"""
enum archive_event_update_column {
	"""
	column name
	"""
	args

	"""
	column name
	"""
	block_id

	"""
	column name
	"""
	call_id

	"""
	column name
	"""
	extrinsic_id

	"""
	column name
	"""
	id

	"""
	column name
	"""
	index_in_block

	"""
	column name
	"""
	name

	"""
	column name
	"""
	phase

	"""
	column name
	"""
	pos
}

input archive_event_updates {
	"""
	append existing jsonb value of filtered columns with new jsonb value
	"""
	_append: archive_event_append_input

	"""
	delete the field or element with specified path (for JSON arrays, negative integers count from the end)
	"""
	_delete_at_path: archive_event_delete_at_path_input

	"""
	delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
	"""
	_delete_elem: archive_event_delete_elem_input

	"""
	delete key/value pair or string element. key/value pairs are matched based on their key value
	"""
	_delete_key: archive_event_delete_key_input

	"""
	increments the numeric columns with given value of the filtered values
	"""
	_inc: archive_event_inc_input

	"""
	prepend existing jsonb value of filtered columns with new jsonb value
	"""
	_prepend: archive_event_prepend_input

	"""
	sets the columns of the filtered rows to the given values
	"""
	_set: archive_event_set_input
	where: archive_event_bool_exp!
}

"""
aggregate var_pop on columns
"""
type archive_event_var_pop_fields {
	index_in_block: Float
	pos: Float
}

"""
order by var_pop() on columns of table "event"
"""
input archive_event_var_pop_order_by {
	index_in_block: order_by
	pos: order_by
}

"""
aggregate var_samp on columns
"""
type archive_event_var_samp_fields {
	index_in_block: Float
	pos: Float
}

"""
order by var_samp() on columns of table "event"
"""
input archive_event_var_samp_order_by {
	index_in_block: order_by
	pos: order_by
}

"""
aggregate variance on columns
"""
type archive_event_variance_fields {
	index_in_block: Float
	pos: Float
}

"""
order by variance() on columns of table "event"
"""
input archive_event_variance_order_by {
	index_in_block: order_by
	pos: order_by
}

"""
columns and relationships of "extrinsic"
"""
type archive_extrinsic {
	"""
	An object relationship
	"""
	block: archive_block!
	block_id: bpchar!
	call_id: String!

	"""
	An array relationship
	"""
	calls(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_call_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_call_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_call_bool_exp
	): [archive_call!]!

	"""
	An aggregate relationship
	"""
	calls_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_call_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_call_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_call_bool_exp
	): archive_call_aggregate!
	error(
		"""
		JSON select path
		"""
		path: String
	): jsonb

	"""
	An array relationship
	"""
	events(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_event_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_event_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_event_bool_exp
	): [archive_event!]!

	"""
	An aggregate relationship
	"""
	events_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [archive_event_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [archive_event_order_by!]

		"""
		filter the rows returned
		"""
		where: archive_event_bool_exp
	): archive_event_aggregate!
	fee: numeric
	hash: bpchar!
	id: bpchar!
	index_in_block: Int!
	pos: Int!
	signature(
		"""
		JSON select path
		"""
		path: String
	): jsonb
	success: Boolean!
	tip: numeric
	version: Int!
}

"""
aggregated selection of "extrinsic"
"""
type archive_extrinsic_aggregate {
	aggregate: archive_extrinsic_aggregate_fields
	nodes: [archive_extrinsic!]!
}

"""
aggregate fields of "extrinsic"
"""
type archive_extrinsic_aggregate_fields {
	avg: archive_extrinsic_avg_fields
	count(columns: [archive_extrinsic_select_column!], distinct: Boolean): Int!
	max: archive_extrinsic_max_fields
	min: archive_extrinsic_min_fields
	stddev: archive_extrinsic_stddev_fields
	stddev_pop: archive_extrinsic_stddev_pop_fields
	stddev_samp: archive_extrinsic_stddev_samp_fields
	sum: archive_extrinsic_sum_fields
	var_pop: archive_extrinsic_var_pop_fields
	var_samp: archive_extrinsic_var_samp_fields
	variance: archive_extrinsic_variance_fields
}

"""
order by aggregate values of table "extrinsic"
"""
input archive_extrinsic_aggregate_order_by {
	avg: archive_extrinsic_avg_order_by
	count: order_by
	max: archive_extrinsic_max_order_by
	min: archive_extrinsic_min_order_by
	stddev: archive_extrinsic_stddev_order_by
	stddev_pop: archive_extrinsic_stddev_pop_order_by
	stddev_samp: archive_extrinsic_stddev_samp_order_by
	sum: archive_extrinsic_sum_order_by
	var_pop: archive_extrinsic_var_pop_order_by
	var_samp: archive_extrinsic_var_samp_order_by
	variance: archive_extrinsic_variance_order_by
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input archive_extrinsic_append_input {
	error: jsonb
	signature: jsonb
}

"""
input type for inserting array relation for remote table "extrinsic"
"""
input archive_extrinsic_arr_rel_insert_input {
	data: [archive_extrinsic_insert_input!]!

	"""
	upsert condition
	"""
	on_conflict: archive_extrinsic_on_conflict
}

"""
aggregate avg on columns
"""
type archive_extrinsic_avg_fields {
	fee: Float
	index_in_block: Float
	pos: Float
	tip: Float
	version: Float
}

"""
order by avg() on columns of table "extrinsic"
"""
input archive_extrinsic_avg_order_by {
	fee: order_by
	index_in_block: order_by
	pos: order_by
	tip: order_by
	version: order_by
}

"""
Boolean expression to filter rows from the table "extrinsic". All fields are combined with a logical 'AND'.
"""
input archive_extrinsic_bool_exp {
	_and: [archive_extrinsic_bool_exp!]
	_not: archive_extrinsic_bool_exp
	_or: [archive_extrinsic_bool_exp!]
	block: archive_block_bool_exp
	block_id: bpchar_comparison_exp
	call_id: String_comparison_exp
	calls: archive_call_bool_exp
	error: jsonb_comparison_exp
	events: archive_event_bool_exp
	fee: numeric_comparison_exp
	hash: bpchar_comparison_exp
	id: bpchar_comparison_exp
	index_in_block: Int_comparison_exp
	pos: Int_comparison_exp
	signature: jsonb_comparison_exp
	success: Boolean_comparison_exp
	tip: numeric_comparison_exp
	version: Int_comparison_exp
}

"""
unique or primary key constraints on table "extrinsic"
"""
enum archive_extrinsic_constraint {
	"""
	unique or primary key constraint on columns "id"
	"""
	extrinsic_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input archive_extrinsic_delete_at_path_input {
	error: [String!]
	signature: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input archive_extrinsic_delete_elem_input {
	error: Int
	signature: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input archive_extrinsic_delete_key_input {
	error: String
	signature: String
}

"""
input type for incrementing numeric columns in table "extrinsic"
"""
input archive_extrinsic_inc_input {
	fee: numeric
	index_in_block: Int
	pos: Int
	tip: numeric
	version: Int
}

"""
input type for inserting data into table "extrinsic"
"""
input archive_extrinsic_insert_input {
	block: archive_block_obj_rel_insert_input
	block_id: bpchar
	call_id: String
	calls: archive_call_arr_rel_insert_input
	error: jsonb
	events: archive_event_arr_rel_insert_input
	fee: numeric
	hash: bpchar
	id: bpchar
	index_in_block: Int
	pos: Int
	signature: jsonb
	success: Boolean
	tip: numeric
	version: Int
}

"""
aggregate max on columns
"""
type archive_extrinsic_max_fields {
	block_id: bpchar
	call_id: String
	fee: numeric
	hash: bpchar
	id: bpchar
	index_in_block: Int
	pos: Int
	tip: numeric
	version: Int
}

"""
order by max() on columns of table "extrinsic"
"""
input archive_extrinsic_max_order_by {
	block_id: order_by
	call_id: order_by
	fee: order_by
	hash: order_by
	id: order_by
	index_in_block: order_by
	pos: order_by
	tip: order_by
	version: order_by
}

"""
aggregate min on columns
"""
type archive_extrinsic_min_fields {
	block_id: bpchar
	call_id: String
	fee: numeric
	hash: bpchar
	id: bpchar
	index_in_block: Int
	pos: Int
	tip: numeric
	version: Int
}

"""
order by min() on columns of table "extrinsic"
"""
input archive_extrinsic_min_order_by {
	block_id: order_by
	call_id: order_by
	fee: order_by
	hash: order_by
	id: order_by
	index_in_block: order_by
	pos: order_by
	tip: order_by
	version: order_by
}

"""
response of any mutation on the table "extrinsic"
"""
type archive_extrinsic_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!

	"""
	data from the rows affected by the mutation
	"""
	returning: [archive_extrinsic!]!
}

"""
input type for inserting object relation for remote table "extrinsic"
"""
input archive_extrinsic_obj_rel_insert_input {
	data: archive_extrinsic_insert_input!

	"""
	upsert condition
	"""
	on_conflict: archive_extrinsic_on_conflict
}

"""
on_conflict condition type for table "extrinsic"
"""
input archive_extrinsic_on_conflict {
	constraint: archive_extrinsic_constraint!
	update_columns: [archive_extrinsic_update_column!]! = []
	where: archive_extrinsic_bool_exp
}

"""
Ordering options when selecting data from "extrinsic".
"""
input archive_extrinsic_order_by {
	block: archive_block_order_by
	block_id: order_by
	call_id: order_by
	calls_aggregate: archive_call_aggregate_order_by
	error: order_by
	events_aggregate: archive_event_aggregate_order_by
	fee: order_by
	hash: order_by
	id: order_by
	index_in_block: order_by
	pos: order_by
	signature: order_by
	success: order_by
	tip: order_by
	version: order_by
}

"""
primary key columns input for table: extrinsic
"""
input archive_extrinsic_pk_columns_input {
	id: bpchar!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input archive_extrinsic_prepend_input {
	error: jsonb
	signature: jsonb
}

"""
select columns of table "extrinsic"
"""
enum archive_extrinsic_select_column {
	"""
	column name
	"""
	block_id

	"""
	column name
	"""
	call_id

	"""
	column name
	"""
	error

	"""
	column name
	"""
	fee

	"""
	column name
	"""
	hash

	"""
	column name
	"""
	id

	"""
	column name
	"""
	index_in_block

	"""
	column name
	"""
	pos

	"""
	column name
	"""
	signature

	"""
	column name
	"""
	success

	"""
	column name
	"""
	tip

	"""
	column name
	"""
	version
}

"""
input type for updating data in table "extrinsic"
"""
input archive_extrinsic_set_input {
	block_id: bpchar
	call_id: String
	error: jsonb
	fee: numeric
	hash: bpchar
	id: bpchar
	index_in_block: Int
	pos: Int
	signature: jsonb
	success: Boolean
	tip: numeric
	version: Int
}

"""
aggregate stddev on columns
"""
type archive_extrinsic_stddev_fields {
	fee: Float
	index_in_block: Float
	pos: Float
	tip: Float
	version: Float
}

"""
order by stddev() on columns of table "extrinsic"
"""
input archive_extrinsic_stddev_order_by {
	fee: order_by
	index_in_block: order_by
	pos: order_by
	tip: order_by
	version: order_by
}

"""
aggregate stddev_pop on columns
"""
type archive_extrinsic_stddev_pop_fields {
	fee: Float
	index_in_block: Float
	pos: Float
	tip: Float
	version: Float
}

"""
order by stddev_pop() on columns of table "extrinsic"
"""
input archive_extrinsic_stddev_pop_order_by {
	fee: order_by
	index_in_block: order_by
	pos: order_by
	tip: order_by
	version: order_by
}

"""
aggregate stddev_samp on columns
"""
type archive_extrinsic_stddev_samp_fields {
	fee: Float
	index_in_block: Float
	pos: Float
	tip: Float
	version: Float
}

"""
order by stddev_samp() on columns of table "extrinsic"
"""
input archive_extrinsic_stddev_samp_order_by {
	fee: order_by
	index_in_block: order_by
	pos: order_by
	tip: order_by
	version: order_by
}

"""
Streaming cursor of the table "extrinsic"
"""
input archive_extrinsic_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: archive_extrinsic_stream_cursor_value_input!

	"""
	cursor ordering
	"""
	ordering: archive_cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input archive_extrinsic_stream_cursor_value_input {
	block_id: bpchar
	call_id: String
	error: jsonb
	fee: numeric
	hash: bpchar
	id: bpchar
	index_in_block: Int
	pos: Int
	signature: jsonb
	success: Boolean
	tip: numeric
	version: Int
}

"""
aggregate sum on columns
"""
type archive_extrinsic_sum_fields {
	fee: numeric
	index_in_block: Int
	pos: Int
	tip: numeric
	version: Int
}

"""
order by sum() on columns of table "extrinsic"
"""
input archive_extrinsic_sum_order_by {
	fee: order_by
	index_in_block: order_by
	pos: order_by
	tip: order_by
	version: order_by
}

"""
update columns of table "extrinsic"
"""
enum archive_extrinsic_update_column {
	"""
	column name
	"""
	block_id

	"""
	column name
	"""
	call_id

	"""
	column name
	"""
	error

	"""
	column name
	"""
	fee

	"""
	column name
	"""
	hash

	"""
	column name
	"""
	id

	"""
	column name
	"""
	index_in_block

	"""
	column name
	"""
	pos

	"""
	column name
	"""
	signature

	"""
	column name
	"""
	success

	"""
	column name
	"""
	tip

	"""
	column name
	"""
	version
}

input archive_extrinsic_updates {
	"""
	append existing jsonb value of filtered columns with new jsonb value
	"""
	_append: archive_extrinsic_append_input

	"""
	delete the field or element with specified path (for JSON arrays, negative integers count from the end)
	"""
	_delete_at_path: archive_extrinsic_delete_at_path_input

	"""
	delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
	"""
	_delete_elem: archive_extrinsic_delete_elem_input

	"""
	delete key/value pair or string element. key/value pairs are matched based on their key value
	"""
	_delete_key: archive_extrinsic_delete_key_input

	"""
	increments the numeric columns with given value of the filtered values
	"""
	_inc: archive_extrinsic_inc_input

	"""
	prepend existing jsonb value of filtered columns with new jsonb value
	"""
	_prepend: archive_extrinsic_prepend_input

	"""
	sets the columns of the filtered rows to the given values
	"""
	_set: archive_extrinsic_set_input
	where: archive_extrinsic_bool_exp!
}

"""
aggregate var_pop on columns
"""
type archive_extrinsic_var_pop_fields {
	fee: Float
	index_in_block: Float
	pos: Float
	tip: Float
	version: Float
}

"""
order by var_pop() on columns of table "extrinsic"
"""
input archive_extrinsic_var_pop_order_by {
	fee: order_by
	index_in_block: order_by
	pos: order_by
	tip: order_by
	version: order_by
}

"""
aggregate var_samp on columns
"""
type archive_extrinsic_var_samp_fields {
	fee: Float
	index_in_block: Float
	pos: Float
	tip: Float
	version: Float
}

"""
order by var_samp() on columns of table "extrinsic"
"""
input archive_extrinsic_var_samp_order_by {
	fee: order_by
	index_in_block: order_by
	pos: order_by
	tip: order_by
	version: order_by
}

"""
aggregate variance on columns
"""
type archive_extrinsic_variance_fields {
	fee: Float
	index_in_block: Float
	pos: Float
	tip: Float
	version: Float
}

"""
order by variance() on columns of table "extrinsic"
"""
input archive_extrinsic_variance_order_by {
	fee: order_by
	index_in_block: order_by
	pos: order_by
	tip: order_by
	version: order_by
}

"""
columns and relationships of "frontier_ethereum_transaction"
"""
type archive_frontier_ethereum_transaction {
	"""
	An object relationship
	"""
	call: archive_call!
	call_id: String!
	contract: bpchar!
	sighash: String
}

"""
aggregated selection of "frontier_ethereum_transaction"
"""
type archive_frontier_ethereum_transaction_aggregate {
	aggregate: archive_frontier_ethereum_transaction_aggregate_fields
	nodes: [archive_frontier_ethereum_transaction!]!
}

"""
aggregate fields of "frontier_ethereum_transaction"
"""
type archive_frontier_ethereum_transaction_aggregate_fields {
	count(
		columns: [archive_frontier_ethereum_transaction_select_column!]
		distinct: Boolean
	): Int!
	max: archive_frontier_ethereum_transaction_max_fields
	min: archive_frontier_ethereum_transaction_min_fields
}

"""
order by aggregate values of table "frontier_ethereum_transaction"
"""
input archive_frontier_ethereum_transaction_aggregate_order_by {
	count: order_by
	max: archive_frontier_ethereum_transaction_max_order_by
	min: archive_frontier_ethereum_transaction_min_order_by
}

"""
input type for inserting array relation for remote table "frontier_ethereum_transaction"
"""
input archive_frontier_ethereum_transaction_arr_rel_insert_input {
	data: [archive_frontier_ethereum_transaction_insert_input!]!

	"""
	upsert condition
	"""
	on_conflict: archive_frontier_ethereum_transaction_on_conflict
}

"""
Boolean expression to filter rows from the table "frontier_ethereum_transaction". All fields are combined with a logical 'AND'.
"""
input archive_frontier_ethereum_transaction_bool_exp {
	_and: [archive_frontier_ethereum_transaction_bool_exp!]
	_not: archive_frontier_ethereum_transaction_bool_exp
	_or: [archive_frontier_ethereum_transaction_bool_exp!]
	call: archive_call_bool_exp
	call_id: String_comparison_exp
	contract: bpchar_comparison_exp
	sighash: String_comparison_exp
}

"""
unique or primary key constraints on table "frontier_ethereum_transaction"
"""
enum archive_frontier_ethereum_transaction_constraint {
	"""
	unique or primary key constraint on columns "call_id"
	"""
	frontier_ethereum_transaction_pkey
}

"""
input type for inserting data into table "frontier_ethereum_transaction"
"""
input archive_frontier_ethereum_transaction_insert_input {
	call: archive_call_obj_rel_insert_input
	call_id: String
	contract: bpchar
	sighash: String
}

"""
aggregate max on columns
"""
type archive_frontier_ethereum_transaction_max_fields {
	call_id: String
	contract: bpchar
	sighash: String
}

"""
order by max() on columns of table "frontier_ethereum_transaction"
"""
input archive_frontier_ethereum_transaction_max_order_by {
	call_id: order_by
	contract: order_by
	sighash: order_by
}

"""
aggregate min on columns
"""
type archive_frontier_ethereum_transaction_min_fields {
	call_id: String
	contract: bpchar
	sighash: String
}

"""
order by min() on columns of table "frontier_ethereum_transaction"
"""
input archive_frontier_ethereum_transaction_min_order_by {
	call_id: order_by
	contract: order_by
	sighash: order_by
}

"""
response of any mutation on the table "frontier_ethereum_transaction"
"""
type archive_frontier_ethereum_transaction_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!

	"""
	data from the rows affected by the mutation
	"""
	returning: [archive_frontier_ethereum_transaction!]!
}

"""
on_conflict condition type for table "frontier_ethereum_transaction"
"""
input archive_frontier_ethereum_transaction_on_conflict {
	constraint: archive_frontier_ethereum_transaction_constraint!
	update_columns: [archive_frontier_ethereum_transaction_update_column!]! = []
	where: archive_frontier_ethereum_transaction_bool_exp
}

"""
Ordering options when selecting data from "frontier_ethereum_transaction".
"""
input archive_frontier_ethereum_transaction_order_by {
	call: archive_call_order_by
	call_id: order_by
	contract: order_by
	sighash: order_by
}

"""
primary key columns input for table: frontier_ethereum_transaction
"""
input archive_frontier_ethereum_transaction_pk_columns_input {
	call_id: String!
}

"""
select columns of table "frontier_ethereum_transaction"
"""
enum archive_frontier_ethereum_transaction_select_column {
	"""
	column name
	"""
	call_id

	"""
	column name
	"""
	contract

	"""
	column name
	"""
	sighash
}

"""
input type for updating data in table "frontier_ethereum_transaction"
"""
input archive_frontier_ethereum_transaction_set_input {
	call_id: String
	contract: bpchar
	sighash: String
}

"""
Streaming cursor of the table "frontier_ethereum_transaction"
"""
input archive_frontier_ethereum_transaction_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: archive_frontier_ethereum_transaction_stream_cursor_value_input!

	"""
	cursor ordering
	"""
	ordering: archive_cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input archive_frontier_ethereum_transaction_stream_cursor_value_input {
	call_id: String
	contract: bpchar
	sighash: String
}

"""
update columns of table "frontier_ethereum_transaction"
"""
enum archive_frontier_ethereum_transaction_update_column {
	"""
	column name
	"""
	call_id

	"""
	column name
	"""
	contract

	"""
	column name
	"""
	sighash
}

input archive_frontier_ethereum_transaction_updates {
	"""
	sets the columns of the filtered rows to the given values
	"""
	_set: archive_frontier_ethereum_transaction_set_input
	where: archive_frontier_ethereum_transaction_bool_exp!
}

"""
columns and relationships of "frontier_evm_log"
"""
type archive_frontier_evm_log {
	contract: bpchar!

	"""
	An object relationship
	"""
	event: archive_event!
	event_id: bpchar!
	topic0: bpchar
	topic1: bpchar
	topic2: bpchar
	topic3: bpchar
}

"""
aggregated selection of "frontier_evm_log"
"""
type archive_frontier_evm_log_aggregate {
	aggregate: archive_frontier_evm_log_aggregate_fields
	nodes: [archive_frontier_evm_log!]!
}

"""
aggregate fields of "frontier_evm_log"
"""
type archive_frontier_evm_log_aggregate_fields {
	count(
		columns: [archive_frontier_evm_log_select_column!]
		distinct: Boolean
	): Int!
	max: archive_frontier_evm_log_max_fields
	min: archive_frontier_evm_log_min_fields
}

"""
order by aggregate values of table "frontier_evm_log"
"""
input archive_frontier_evm_log_aggregate_order_by {
	count: order_by
	max: archive_frontier_evm_log_max_order_by
	min: archive_frontier_evm_log_min_order_by
}

"""
input type for inserting array relation for remote table "frontier_evm_log"
"""
input archive_frontier_evm_log_arr_rel_insert_input {
	data: [archive_frontier_evm_log_insert_input!]!

	"""
	upsert condition
	"""
	on_conflict: archive_frontier_evm_log_on_conflict
}

"""
Boolean expression to filter rows from the table "frontier_evm_log". All fields are combined with a logical 'AND'.
"""
input archive_frontier_evm_log_bool_exp {
	_and: [archive_frontier_evm_log_bool_exp!]
	_not: archive_frontier_evm_log_bool_exp
	_or: [archive_frontier_evm_log_bool_exp!]
	contract: bpchar_comparison_exp
	event: archive_event_bool_exp
	event_id: bpchar_comparison_exp
	topic0: bpchar_comparison_exp
	topic1: bpchar_comparison_exp
	topic2: bpchar_comparison_exp
	topic3: bpchar_comparison_exp
}

"""
unique or primary key constraints on table "frontier_evm_log"
"""
enum archive_frontier_evm_log_constraint {
	"""
	unique or primary key constraint on columns "event_id"
	"""
	frontier_evm_log_pkey
}

"""
input type for inserting data into table "frontier_evm_log"
"""
input archive_frontier_evm_log_insert_input {
	contract: bpchar
	event: archive_event_obj_rel_insert_input
	event_id: bpchar
	topic0: bpchar
	topic1: bpchar
	topic2: bpchar
	topic3: bpchar
}

"""
aggregate max on columns
"""
type archive_frontier_evm_log_max_fields {
	contract: bpchar
	event_id: bpchar
	topic0: bpchar
	topic1: bpchar
	topic2: bpchar
	topic3: bpchar
}

"""
order by max() on columns of table "frontier_evm_log"
"""
input archive_frontier_evm_log_max_order_by {
	contract: order_by
	event_id: order_by
	topic0: order_by
	topic1: order_by
	topic2: order_by
	topic3: order_by
}

"""
aggregate min on columns
"""
type archive_frontier_evm_log_min_fields {
	contract: bpchar
	event_id: bpchar
	topic0: bpchar
	topic1: bpchar
	topic2: bpchar
	topic3: bpchar
}

"""
order by min() on columns of table "frontier_evm_log"
"""
input archive_frontier_evm_log_min_order_by {
	contract: order_by
	event_id: order_by
	topic0: order_by
	topic1: order_by
	topic2: order_by
	topic3: order_by
}

"""
response of any mutation on the table "frontier_evm_log"
"""
type archive_frontier_evm_log_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!

	"""
	data from the rows affected by the mutation
	"""
	returning: [archive_frontier_evm_log!]!
}

"""
on_conflict condition type for table "frontier_evm_log"
"""
input archive_frontier_evm_log_on_conflict {
	constraint: archive_frontier_evm_log_constraint!
	update_columns: [archive_frontier_evm_log_update_column!]! = []
	where: archive_frontier_evm_log_bool_exp
}

"""
Ordering options when selecting data from "frontier_evm_log".
"""
input archive_frontier_evm_log_order_by {
	contract: order_by
	event: archive_event_order_by
	event_id: order_by
	topic0: order_by
	topic1: order_by
	topic2: order_by
	topic3: order_by
}

"""
primary key columns input for table: frontier_evm_log
"""
input archive_frontier_evm_log_pk_columns_input {
	event_id: bpchar!
}

"""
select columns of table "frontier_evm_log"
"""
enum archive_frontier_evm_log_select_column {
	"""
	column name
	"""
	contract

	"""
	column name
	"""
	event_id

	"""
	column name
	"""
	topic0

	"""
	column name
	"""
	topic1

	"""
	column name
	"""
	topic2

	"""
	column name
	"""
	topic3
}

"""
input type for updating data in table "frontier_evm_log"
"""
input archive_frontier_evm_log_set_input {
	contract: bpchar
	event_id: bpchar
	topic0: bpchar
	topic1: bpchar
	topic2: bpchar
	topic3: bpchar
}

"""
Streaming cursor of the table "frontier_evm_log"
"""
input archive_frontier_evm_log_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: archive_frontier_evm_log_stream_cursor_value_input!

	"""
	cursor ordering
	"""
	ordering: archive_cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input archive_frontier_evm_log_stream_cursor_value_input {
	contract: bpchar
	event_id: bpchar
	topic0: bpchar
	topic1: bpchar
	topic2: bpchar
	topic3: bpchar
}

"""
update columns of table "frontier_evm_log"
"""
enum archive_frontier_evm_log_update_column {
	"""
	column name
	"""
	contract

	"""
	column name
	"""
	event_id

	"""
	column name
	"""
	topic0

	"""
	column name
	"""
	topic1

	"""
	column name
	"""
	topic2

	"""
	column name
	"""
	topic3
}

input archive_frontier_evm_log_updates {
	"""
	sets the columns of the filtered rows to the given values
	"""
	_set: archive_frontier_evm_log_set_input
	where: archive_frontier_evm_log_bool_exp!
}

"""
columns and relationships of "metadata"
"""
type archive_metadata {
	block_hash: bpchar!
	block_height: Int!
	hex: String!
	id: String!
	spec_name: String!
	spec_version: Int
}

"""
aggregated selection of "metadata"
"""
type archive_metadata_aggregate {
	aggregate: archive_metadata_aggregate_fields
	nodes: [archive_metadata!]!
}

"""
aggregate fields of "metadata"
"""
type archive_metadata_aggregate_fields {
	avg: archive_metadata_avg_fields
	count(columns: [archive_metadata_select_column!], distinct: Boolean): Int!
	max: archive_metadata_max_fields
	min: archive_metadata_min_fields
	stddev: archive_metadata_stddev_fields
	stddev_pop: archive_metadata_stddev_pop_fields
	stddev_samp: archive_metadata_stddev_samp_fields
	sum: archive_metadata_sum_fields
	var_pop: archive_metadata_var_pop_fields
	var_samp: archive_metadata_var_samp_fields
	variance: archive_metadata_variance_fields
}

"""
aggregate avg on columns
"""
type archive_metadata_avg_fields {
	block_height: Float
	spec_version: Float
}

"""
Boolean expression to filter rows from the table "metadata". All fields are combined with a logical 'AND'.
"""
input archive_metadata_bool_exp {
	_and: [archive_metadata_bool_exp!]
	_not: archive_metadata_bool_exp
	_or: [archive_metadata_bool_exp!]
	block_hash: bpchar_comparison_exp
	block_height: Int_comparison_exp
	hex: String_comparison_exp
	id: String_comparison_exp
	spec_name: String_comparison_exp
	spec_version: Int_comparison_exp
}

"""
unique or primary key constraints on table "metadata"
"""
enum archive_metadata_constraint {
	"""
	unique or primary key constraint on columns "id"
	"""
	metadata_pkey
}

"""
input type for incrementing numeric columns in table "metadata"
"""
input archive_metadata_inc_input {
	block_height: Int
	spec_version: Int
}

"""
input type for inserting data into table "metadata"
"""
input archive_metadata_insert_input {
	block_hash: bpchar
	block_height: Int
	hex: String
	id: String
	spec_name: String
	spec_version: Int
}

"""
aggregate max on columns
"""
type archive_metadata_max_fields {
	block_hash: bpchar
	block_height: Int
	hex: String
	id: String
	spec_name: String
	spec_version: Int
}

"""
aggregate min on columns
"""
type archive_metadata_min_fields {
	block_hash: bpchar
	block_height: Int
	hex: String
	id: String
	spec_name: String
	spec_version: Int
}

"""
response of any mutation on the table "metadata"
"""
type archive_metadata_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!

	"""
	data from the rows affected by the mutation
	"""
	returning: [archive_metadata!]!
}

"""
on_conflict condition type for table "metadata"
"""
input archive_metadata_on_conflict {
	constraint: archive_metadata_constraint!
	update_columns: [archive_metadata_update_column!]! = []
	where: archive_metadata_bool_exp
}

"""
Ordering options when selecting data from "metadata".
"""
input archive_metadata_order_by {
	block_hash: order_by
	block_height: order_by
	hex: order_by
	id: order_by
	spec_name: order_by
	spec_version: order_by
}

"""
primary key columns input for table: metadata
"""
input archive_metadata_pk_columns_input {
	id: String!
}

"""
select columns of table "metadata"
"""
enum archive_metadata_select_column {
	"""
	column name
	"""
	block_hash

	"""
	column name
	"""
	block_height

	"""
	column name
	"""
	hex

	"""
	column name
	"""
	id

	"""
	column name
	"""
	spec_name

	"""
	column name
	"""
	spec_version
}

"""
input type for updating data in table "metadata"
"""
input archive_metadata_set_input {
	block_hash: bpchar
	block_height: Int
	hex: String
	id: String
	spec_name: String
	spec_version: Int
}

"""
aggregate stddev on columns
"""
type archive_metadata_stddev_fields {
	block_height: Float
	spec_version: Float
}

"""
aggregate stddev_pop on columns
"""
type archive_metadata_stddev_pop_fields {
	block_height: Float
	spec_version: Float
}

"""
aggregate stddev_samp on columns
"""
type archive_metadata_stddev_samp_fields {
	block_height: Float
	spec_version: Float
}

"""
Streaming cursor of the table "metadata"
"""
input archive_metadata_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: archive_metadata_stream_cursor_value_input!

	"""
	cursor ordering
	"""
	ordering: archive_cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input archive_metadata_stream_cursor_value_input {
	block_hash: bpchar
	block_height: Int
	hex: String
	id: String
	spec_name: String
	spec_version: Int
}

"""
aggregate sum on columns
"""
type archive_metadata_sum_fields {
	block_height: Int
	spec_version: Int
}

"""
update columns of table "metadata"
"""
enum archive_metadata_update_column {
	"""
	column name
	"""
	block_hash

	"""
	column name
	"""
	block_height

	"""
	column name
	"""
	hex

	"""
	column name
	"""
	id

	"""
	column name
	"""
	spec_name

	"""
	column name
	"""
	spec_version
}

input archive_metadata_updates {
	"""
	increments the numeric columns with given value of the filtered values
	"""
	_inc: archive_metadata_inc_input

	"""
	sets the columns of the filtered rows to the given values
	"""
	_set: archive_metadata_set_input
	where: archive_metadata_bool_exp!
}

"""
aggregate var_pop on columns
"""
type archive_metadata_var_pop_fields {
	block_height: Float
	spec_version: Float
}

"""
aggregate var_samp on columns
"""
type archive_metadata_var_samp_fields {
	block_height: Float
	spec_version: Float
}

"""
aggregate variance on columns
"""
type archive_metadata_variance_fields {
	block_height: Float
	spec_version: Float
}

"""
columns and relationships of "squid_processor.account"
"""
type balances_account {
	free: numeric!
	id: String!
	reserved: numeric!
	total: numeric!

	"""
	An array relationship
	"""
	transfers(
		"""
		distinct select on columns
		"""
		distinct_on: [balances_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [balances_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: balances_transfer_bool_exp
	): [balances_transfer!]!

	"""
	An array relationship
	"""
	transfersByFromId(
		"""
		distinct select on columns
		"""
		distinct_on: [balances_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [balances_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: balances_transfer_bool_exp
	): [balances_transfer!]!

	"""
	An aggregate relationship
	"""
	transfersByFromId_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [balances_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [balances_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: balances_transfer_bool_exp
	): balances_transfer_aggregate!

	"""
	An aggregate relationship
	"""
	transfers_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [balances_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [balances_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: balances_transfer_bool_exp
	): balances_transfer_aggregate!
	updated_at: Int
}

"""
aggregated selection of "squid_processor.account"
"""
type balances_account_aggregate {
	aggregate: balances_account_aggregate_fields
	nodes: [balances_account!]!
}

"""
aggregate fields of "squid_processor.account"
"""
type balances_account_aggregate_fields {
	avg: balances_account_avg_fields
	count(columns: [balances_account_select_column!], distinct: Boolean): Int!
	max: balances_account_max_fields
	min: balances_account_min_fields
	stddev: balances_account_stddev_fields
	stddev_pop: balances_account_stddev_pop_fields
	stddev_samp: balances_account_stddev_samp_fields
	sum: balances_account_sum_fields
	var_pop: balances_account_var_pop_fields
	var_samp: balances_account_var_samp_fields
	variance: balances_account_variance_fields
}

"""
aggregate avg on columns
"""
type balances_account_avg_fields {
	free: Float
	reserved: Float
	total: Float
	updated_at: Float
}

"""
Boolean expression to filter rows from the table "squid_processor.account". All fields are combined with a logical 'AND'.
"""
input balances_account_bool_exp {
	_and: [balances_account_bool_exp!]
	_not: balances_account_bool_exp
	_or: [balances_account_bool_exp!]
	free: numeric_comparison_exp
	id: String_comparison_exp
	reserved: numeric_comparison_exp
	total: numeric_comparison_exp
	transfers: balances_transfer_bool_exp
	transfersByFromId: balances_transfer_bool_exp
	updated_at: Int_comparison_exp
}

"""
unique or primary key constraints on table "squid_processor.account"
"""
enum balances_account_constraint {
	"""
	unique or primary key constraint on columns "id"
	"""
	PK_54115ee388cdb6d86bb4bf5b2ea
}

"""
input type for incrementing numeric columns in table "squid_processor.account"
"""
input balances_account_inc_input {
	free: numeric
	reserved: numeric
	total: numeric
	updated_at: Int
}

"""
input type for inserting data into table "squid_processor.account"
"""
input balances_account_insert_input {
	free: numeric
	id: String
	reserved: numeric
	total: numeric
	transfers: balances_transfer_arr_rel_insert_input
	transfersByFromId: balances_transfer_arr_rel_insert_input
	updated_at: Int
}

"""
aggregate max on columns
"""
type balances_account_max_fields {
	free: numeric
	id: String
	reserved: numeric
	total: numeric
	updated_at: Int
}

"""
aggregate min on columns
"""
type balances_account_min_fields {
	free: numeric
	id: String
	reserved: numeric
	total: numeric
	updated_at: Int
}

"""
response of any mutation on the table "squid_processor.account"
"""
type balances_account_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!

	"""
	data from the rows affected by the mutation
	"""
	returning: [balances_account!]!
}

"""
input type for inserting object relation for remote table "squid_processor.account"
"""
input balances_account_obj_rel_insert_input {
	data: balances_account_insert_input!

	"""
	upsert condition
	"""
	on_conflict: balances_account_on_conflict
}

"""
on_conflict condition type for table "squid_processor.account"
"""
input balances_account_on_conflict {
	constraint: balances_account_constraint!
	update_columns: [balances_account_update_column!]! = []
	where: balances_account_bool_exp
}

"""
Ordering options when selecting data from "squid_processor.account".
"""
input balances_account_order_by {
	free: order_by
	id: order_by
	reserved: order_by
	total: order_by
	transfersByFromId_aggregate: balances_transfer_aggregate_order_by
	transfers_aggregate: balances_transfer_aggregate_order_by
	updated_at: order_by
}

"""
primary key columns input for table: account
"""
input balances_account_pk_columns_input {
	id: String!
}

"""
select columns of table "squid_processor.account"
"""
enum balances_account_select_column {
	"""
	column name
	"""
	free

	"""
	column name
	"""
	id

	"""
	column name
	"""
	reserved

	"""
	column name
	"""
	total

	"""
	column name
	"""
	updated_at
}

"""
input type for updating data in table "squid_processor.account"
"""
input balances_account_set_input {
	free: numeric
	id: String
	reserved: numeric
	total: numeric
	updated_at: Int
}

"""
aggregate stddev on columns
"""
type balances_account_stddev_fields {
	free: Float
	reserved: Float
	total: Float
	updated_at: Float
}

"""
aggregate stddev_pop on columns
"""
type balances_account_stddev_pop_fields {
	free: Float
	reserved: Float
	total: Float
	updated_at: Float
}

"""
aggregate stddev_samp on columns
"""
type balances_account_stddev_samp_fields {
	free: Float
	reserved: Float
	total: Float
	updated_at: Float
}

"""
Streaming cursor of the table "account"
"""
input balances_account_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: balances_account_stream_cursor_value_input!

	"""
	cursor ordering
	"""
	ordering: balances_cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input balances_account_stream_cursor_value_input {
	free: numeric
	id: String
	reserved: numeric
	total: numeric
	updated_at: Int
}

"""
aggregate sum on columns
"""
type balances_account_sum_fields {
	free: numeric
	reserved: numeric
	total: numeric
	updated_at: Int
}

"""
update columns of table "squid_processor.account"
"""
enum balances_account_update_column {
	"""
	column name
	"""
	free

	"""
	column name
	"""
	id

	"""
	column name
	"""
	reserved

	"""
	column name
	"""
	total

	"""
	column name
	"""
	updated_at
}

input balances_account_updates {
	"""
	increments the numeric columns with given value of the filtered values
	"""
	_inc: balances_account_inc_input

	"""
	sets the columns of the filtered rows to the given values
	"""
	_set: balances_account_set_input
	where: balances_account_bool_exp!
}

"""
aggregate var_pop on columns
"""
type balances_account_var_pop_fields {
	free: Float
	reserved: Float
	total: Float
	updated_at: Float
}

"""
aggregate var_samp on columns
"""
type balances_account_var_samp_fields {
	free: Float
	reserved: Float
	total: Float
	updated_at: Float
}

"""
aggregate variance on columns
"""
type balances_account_variance_fields {
	free: Float
	reserved: Float
	total: Float
	updated_at: Float
}

type balances_balances_mutation_frontend {
	"""
	delete data from the table: "squid_processor.account"
	"""
	delete_account(
		"""
		filter the rows which have to be deleted
		"""
		where: balances_account_bool_exp!
	): balances_account_mutation_response

	"""
	delete single row from the table: "squid_processor.account"
	"""
	delete_account_by_pk(id: String!): balances_account

	"""
	delete data from the table: "squid_processor.chain_state"
	"""
	delete_chain_state(
		"""
		filter the rows which have to be deleted
		"""
		where: balances_chain_state_bool_exp!
	): balances_chain_state_mutation_response

	"""
	delete single row from the table: "squid_processor.chain_state"
	"""
	delete_chain_state_by_pk(id: String!): balances_chain_state

	"""
	delete data from the table: "squid_processor.transfer"
	"""
	delete_transfer(
		"""
		filter the rows which have to be deleted
		"""
		where: balances_transfer_bool_exp!
	): balances_transfer_mutation_response

	"""
	delete single row from the table: "squid_processor.transfer"
	"""
	delete_transfer_by_pk(id: String!): balances_transfer

	"""
	insert data into the table: "squid_processor.account"
	"""
	insert_account(
		"""
		the rows to be inserted
		"""
		objects: [balances_account_insert_input!]!

		"""
		upsert condition
		"""
		on_conflict: balances_account_on_conflict
	): balances_account_mutation_response

	"""
	insert a single row into the table: "squid_processor.account"
	"""
	insert_account_one(
		"""
		the row to be inserted
		"""
		object: balances_account_insert_input!

		"""
		upsert condition
		"""
		on_conflict: balances_account_on_conflict
	): balances_account

	"""
	insert data into the table: "squid_processor.chain_state"
	"""
	insert_chain_state(
		"""
		the rows to be inserted
		"""
		objects: [balances_chain_state_insert_input!]!

		"""
		upsert condition
		"""
		on_conflict: balances_chain_state_on_conflict
	): balances_chain_state_mutation_response

	"""
	insert a single row into the table: "squid_processor.chain_state"
	"""
	insert_chain_state_one(
		"""
		the row to be inserted
		"""
		object: balances_chain_state_insert_input!

		"""
		upsert condition
		"""
		on_conflict: balances_chain_state_on_conflict
	): balances_chain_state

	"""
	insert data into the table: "squid_processor.transfer"
	"""
	insert_transfer(
		"""
		the rows to be inserted
		"""
		objects: [balances_transfer_insert_input!]!

		"""
		upsert condition
		"""
		on_conflict: balances_transfer_on_conflict
	): balances_transfer_mutation_response

	"""
	insert a single row into the table: "squid_processor.transfer"
	"""
	insert_transfer_one(
		"""
		the row to be inserted
		"""
		object: balances_transfer_insert_input!

		"""
		upsert condition
		"""
		on_conflict: balances_transfer_on_conflict
	): balances_transfer

	"""
	update data of the table: "squid_processor.account"
	"""
	update_account(
		"""
		increments the numeric columns with given value of the filtered values
		"""
		_inc: balances_account_inc_input

		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: balances_account_set_input

		"""
		filter the rows which have to be updated
		"""
		where: balances_account_bool_exp!
	): balances_account_mutation_response

	"""
	update single row of the table: "squid_processor.account"
	"""
	update_account_by_pk(
		"""
		increments the numeric columns with given value of the filtered values
		"""
		_inc: balances_account_inc_input

		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: balances_account_set_input
		pk_columns: balances_account_pk_columns_input!
	): balances_account

	"""
	update multiples rows of table: "squid_processor.account"
	"""
	update_account_many(
		"""
		updates to execute, in order
		"""
		updates: [balances_account_updates!]!
	): [balances_account_mutation_response]

	"""
	update data of the table: "squid_processor.chain_state"
	"""
	update_chain_state(
		"""
		increments the numeric columns with given value of the filtered values
		"""
		_inc: balances_chain_state_inc_input

		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: balances_chain_state_set_input

		"""
		filter the rows which have to be updated
		"""
		where: balances_chain_state_bool_exp!
	): balances_chain_state_mutation_response

	"""
	update single row of the table: "squid_processor.chain_state"
	"""
	update_chain_state_by_pk(
		"""
		increments the numeric columns with given value of the filtered values
		"""
		_inc: balances_chain_state_inc_input

		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: balances_chain_state_set_input
		pk_columns: balances_chain_state_pk_columns_input!
	): balances_chain_state

	"""
	update multiples rows of table: "squid_processor.chain_state"
	"""
	update_chain_state_many(
		"""
		updates to execute, in order
		"""
		updates: [balances_chain_state_updates!]!
	): [balances_chain_state_mutation_response]

	"""
	update data of the table: "squid_processor.transfer"
	"""
	update_transfer(
		"""
		increments the numeric columns with given value of the filtered values
		"""
		_inc: balances_transfer_inc_input

		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: balances_transfer_set_input

		"""
		filter the rows which have to be updated
		"""
		where: balances_transfer_bool_exp!
	): balances_transfer_mutation_response

	"""
	update single row of the table: "squid_processor.transfer"
	"""
	update_transfer_by_pk(
		"""
		increments the numeric columns with given value of the filtered values
		"""
		_inc: balances_transfer_inc_input

		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: balances_transfer_set_input
		pk_columns: balances_transfer_pk_columns_input!
	): balances_transfer

	"""
	update multiples rows of table: "squid_processor.transfer"
	"""
	update_transfer_many(
		"""
		updates to execute, in order
		"""
		updates: [balances_transfer_updates!]!
	): [balances_transfer_mutation_response]
}

type balances_balances_query {
	"""
	fetch data from the table: "squid_processor.account"
	"""
	account(
		"""
		distinct select on columns
		"""
		distinct_on: [balances_account_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [balances_account_order_by!]

		"""
		filter the rows returned
		"""
		where: balances_account_bool_exp
	): [balances_account!]!

	"""
	fetch aggregated fields from the table: "squid_processor.account"
	"""
	account_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [balances_account_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [balances_account_order_by!]

		"""
		filter the rows returned
		"""
		where: balances_account_bool_exp
	): balances_account_aggregate!

	"""
	fetch data from the table: "squid_processor.account" using primary key columns
	"""
	account_by_pk(id: String!): balances_account

	"""
	fetch data from the table: "squid_processor.chain_state"
	"""
	chain_state(
		"""
		distinct select on columns
		"""
		distinct_on: [balances_chain_state_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [balances_chain_state_order_by!]

		"""
		filter the rows returned
		"""
		where: balances_chain_state_bool_exp
	): [balances_chain_state!]!

	"""
	fetch aggregated fields from the table: "squid_processor.chain_state"
	"""
	chain_state_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [balances_chain_state_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [balances_chain_state_order_by!]

		"""
		filter the rows returned
		"""
		where: balances_chain_state_bool_exp
	): balances_chain_state_aggregate!

	"""
	fetch data from the table: "squid_processor.chain_state" using primary key columns
	"""
	chain_state_by_pk(id: String!): balances_chain_state

	"""
	fetch data from the table: "squid_processor.transfer"
	"""
	transfer(
		"""
		distinct select on columns
		"""
		distinct_on: [balances_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [balances_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: balances_transfer_bool_exp
	): [balances_transfer!]!

	"""
	fetch aggregated fields from the table: "squid_processor.transfer"
	"""
	transfer_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [balances_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [balances_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: balances_transfer_bool_exp
	): balances_transfer_aggregate!

	"""
	fetch data from the table: "squid_processor.transfer" using primary key columns
	"""
	transfer_by_pk(id: String!): balances_transfer
}

type balances_balances_subscription {
	"""
	fetch data from the table: "squid_processor.account"
	"""
	account(
		"""
		distinct select on columns
		"""
		distinct_on: [balances_account_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [balances_account_order_by!]

		"""
		filter the rows returned
		"""
		where: balances_account_bool_exp
	): [balances_account!]!

	"""
	fetch aggregated fields from the table: "squid_processor.account"
	"""
	account_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [balances_account_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [balances_account_order_by!]

		"""
		filter the rows returned
		"""
		where: balances_account_bool_exp
	): balances_account_aggregate!

	"""
	fetch data from the table: "squid_processor.account" using primary key columns
	"""
	account_by_pk(id: String!): balances_account

	"""
	fetch data from the table in a streaming manner : "squid_processor.account"
	"""
	account_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!

		"""
		cursor to stream the results returned by the query
		"""
		cursor: [balances_account_stream_cursor_input]!

		"""
		filter the rows returned
		"""
		where: balances_account_bool_exp
	): [balances_account!]!

	"""
	fetch data from the table: "squid_processor.chain_state"
	"""
	chain_state(
		"""
		distinct select on columns
		"""
		distinct_on: [balances_chain_state_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [balances_chain_state_order_by!]

		"""
		filter the rows returned
		"""
		where: balances_chain_state_bool_exp
	): [balances_chain_state!]!

	"""
	fetch aggregated fields from the table: "squid_processor.chain_state"
	"""
	chain_state_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [balances_chain_state_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [balances_chain_state_order_by!]

		"""
		filter the rows returned
		"""
		where: balances_chain_state_bool_exp
	): balances_chain_state_aggregate!

	"""
	fetch data from the table: "squid_processor.chain_state" using primary key columns
	"""
	chain_state_by_pk(id: String!): balances_chain_state

	"""
	fetch data from the table in a streaming manner : "squid_processor.chain_state"
	"""
	chain_state_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!

		"""
		cursor to stream the results returned by the query
		"""
		cursor: [balances_chain_state_stream_cursor_input]!

		"""
		filter the rows returned
		"""
		where: balances_chain_state_bool_exp
	): [balances_chain_state!]!

	"""
	fetch data from the table: "squid_processor.transfer"
	"""
	transfer(
		"""
		distinct select on columns
		"""
		distinct_on: [balances_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [balances_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: balances_transfer_bool_exp
	): [balances_transfer!]!

	"""
	fetch aggregated fields from the table: "squid_processor.transfer"
	"""
	transfer_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [balances_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [balances_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: balances_transfer_bool_exp
	): balances_transfer_aggregate!

	"""
	fetch data from the table: "squid_processor.transfer" using primary key columns
	"""
	transfer_by_pk(id: String!): balances_transfer

	"""
	fetch data from the table in a streaming manner : "squid_processor.transfer"
	"""
	transfer_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!

		"""
		cursor to stream the results returned by the query
		"""
		cursor: [balances_transfer_stream_cursor_input]!

		"""
		filter the rows returned
		"""
		where: balances_transfer_bool_exp
	): [balances_transfer!]!
}

"""
columns and relationships of "squid_processor.chain_state"
"""
type balances_chain_state {
	block_number: Int!
	id: String!
	timestamp: timestamptz!
	token_balance: numeric!
	token_holders: Int!
}

"""
aggregated selection of "squid_processor.chain_state"
"""
type balances_chain_state_aggregate {
	aggregate: balances_chain_state_aggregate_fields
	nodes: [balances_chain_state!]!
}

"""
aggregate fields of "squid_processor.chain_state"
"""
type balances_chain_state_aggregate_fields {
	avg: balances_chain_state_avg_fields
	count(columns: [balances_chain_state_select_column!], distinct: Boolean): Int!
	max: balances_chain_state_max_fields
	min: balances_chain_state_min_fields
	stddev: balances_chain_state_stddev_fields
	stddev_pop: balances_chain_state_stddev_pop_fields
	stddev_samp: balances_chain_state_stddev_samp_fields
	sum: balances_chain_state_sum_fields
	var_pop: balances_chain_state_var_pop_fields
	var_samp: balances_chain_state_var_samp_fields
	variance: balances_chain_state_variance_fields
}

"""
aggregate avg on columns
"""
type balances_chain_state_avg_fields {
	block_number: Float
	token_balance: Float
	token_holders: Float
}

"""
Boolean expression to filter rows from the table "squid_processor.chain_state". All fields are combined with a logical 'AND'.
"""
input balances_chain_state_bool_exp {
	_and: [balances_chain_state_bool_exp!]
	_not: balances_chain_state_bool_exp
	_or: [balances_chain_state_bool_exp!]
	block_number: Int_comparison_exp
	id: String_comparison_exp
	timestamp: timestamptz_comparison_exp
	token_balance: numeric_comparison_exp
	token_holders: Int_comparison_exp
}

"""
unique or primary key constraints on table "squid_processor.chain_state"
"""
enum balances_chain_state_constraint {
	"""
	unique or primary key constraint on columns "id"
	"""
	PK_e28e46a238ada7cbbcf711b3f6c
}

"""
input type for incrementing numeric columns in table "squid_processor.chain_state"
"""
input balances_chain_state_inc_input {
	block_number: Int
	token_balance: numeric
	token_holders: Int
}

"""
input type for inserting data into table "squid_processor.chain_state"
"""
input balances_chain_state_insert_input {
	block_number: Int
	id: String
	timestamp: timestamptz
	token_balance: numeric
	token_holders: Int
}

"""
aggregate max on columns
"""
type balances_chain_state_max_fields {
	block_number: Int
	id: String
	timestamp: timestamptz
	token_balance: numeric
	token_holders: Int
}

"""
aggregate min on columns
"""
type balances_chain_state_min_fields {
	block_number: Int
	id: String
	timestamp: timestamptz
	token_balance: numeric
	token_holders: Int
}

"""
response of any mutation on the table "squid_processor.chain_state"
"""
type balances_chain_state_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!

	"""
	data from the rows affected by the mutation
	"""
	returning: [balances_chain_state!]!
}

"""
on_conflict condition type for table "squid_processor.chain_state"
"""
input balances_chain_state_on_conflict {
	constraint: balances_chain_state_constraint!
	update_columns: [balances_chain_state_update_column!]! = []
	where: balances_chain_state_bool_exp
}

"""
Ordering options when selecting data from "squid_processor.chain_state".
"""
input balances_chain_state_order_by {
	block_number: order_by
	id: order_by
	timestamp: order_by
	token_balance: order_by
	token_holders: order_by
}

"""
primary key columns input for table: chain_state
"""
input balances_chain_state_pk_columns_input {
	id: String!
}

"""
select columns of table "squid_processor.chain_state"
"""
enum balances_chain_state_select_column {
	"""
	column name
	"""
	block_number

	"""
	column name
	"""
	id

	"""
	column name
	"""
	timestamp

	"""
	column name
	"""
	token_balance

	"""
	column name
	"""
	token_holders
}

"""
input type for updating data in table "squid_processor.chain_state"
"""
input balances_chain_state_set_input {
	block_number: Int
	id: String
	timestamp: timestamptz
	token_balance: numeric
	token_holders: Int
}

"""
aggregate stddev on columns
"""
type balances_chain_state_stddev_fields {
	block_number: Float
	token_balance: Float
	token_holders: Float
}

"""
aggregate stddev_pop on columns
"""
type balances_chain_state_stddev_pop_fields {
	block_number: Float
	token_balance: Float
	token_holders: Float
}

"""
aggregate stddev_samp on columns
"""
type balances_chain_state_stddev_samp_fields {
	block_number: Float
	token_balance: Float
	token_holders: Float
}

"""
Streaming cursor of the table "chain_state"
"""
input balances_chain_state_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: balances_chain_state_stream_cursor_value_input!

	"""
	cursor ordering
	"""
	ordering: balances_cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input balances_chain_state_stream_cursor_value_input {
	block_number: Int
	id: String
	timestamp: timestamptz
	token_balance: numeric
	token_holders: Int
}

"""
aggregate sum on columns
"""
type balances_chain_state_sum_fields {
	block_number: Int
	token_balance: numeric
	token_holders: Int
}

"""
update columns of table "squid_processor.chain_state"
"""
enum balances_chain_state_update_column {
	"""
	column name
	"""
	block_number

	"""
	column name
	"""
	id

	"""
	column name
	"""
	timestamp

	"""
	column name
	"""
	token_balance

	"""
	column name
	"""
	token_holders
}

input balances_chain_state_updates {
	"""
	increments the numeric columns with given value of the filtered values
	"""
	_inc: balances_chain_state_inc_input

	"""
	sets the columns of the filtered rows to the given values
	"""
	_set: balances_chain_state_set_input
	where: balances_chain_state_bool_exp!
}

"""
aggregate var_pop on columns
"""
type balances_chain_state_var_pop_fields {
	block_number: Float
	token_balance: Float
	token_holders: Float
}

"""
aggregate var_samp on columns
"""
type balances_chain_state_var_samp_fields {
	block_number: Float
	token_balance: Float
	token_holders: Float
}

"""
aggregate variance on columns
"""
type balances_chain_state_variance_fields {
	block_number: Float
	token_balance: Float
	token_holders: Float
}

"""
ordering argument of a cursor
"""
enum balances_cursor_ordering {
	"""
	ascending ordering of the cursor
	"""
	ASC

	"""
	descending ordering of the cursor
	"""
	DESC
}

"""
columns and relationships of "squid_processor.transfer"
"""
type balances_transfer {
	"""
	An object relationship
	"""
	account: balances_account

	"""
	An object relationship
	"""
	accountByFromId: balances_account
	amount: numeric!
	asset_id: String!
	block_number: Int!
	extrinsic_hash: String
	from_id: String
	id: String!
	status: String!
	timestamp: timestamptz!
	to_id: String
}

"""
aggregated selection of "squid_processor.transfer"
"""
type balances_transfer_aggregate {
	aggregate: balances_transfer_aggregate_fields
	nodes: [balances_transfer!]!
}

"""
aggregate fields of "squid_processor.transfer"
"""
type balances_transfer_aggregate_fields {
	avg: balances_transfer_avg_fields
	count(columns: [balances_transfer_select_column!], distinct: Boolean): Int!
	max: balances_transfer_max_fields
	min: balances_transfer_min_fields
	stddev: balances_transfer_stddev_fields
	stddev_pop: balances_transfer_stddev_pop_fields
	stddev_samp: balances_transfer_stddev_samp_fields
	sum: balances_transfer_sum_fields
	var_pop: balances_transfer_var_pop_fields
	var_samp: balances_transfer_var_samp_fields
	variance: balances_transfer_variance_fields
}

"""
order by aggregate values of table "squid_processor.transfer"
"""
input balances_transfer_aggregate_order_by {
	avg: balances_transfer_avg_order_by
	count: order_by
	max: balances_transfer_max_order_by
	min: balances_transfer_min_order_by
	stddev: balances_transfer_stddev_order_by
	stddev_pop: balances_transfer_stddev_pop_order_by
	stddev_samp: balances_transfer_stddev_samp_order_by
	sum: balances_transfer_sum_order_by
	var_pop: balances_transfer_var_pop_order_by
	var_samp: balances_transfer_var_samp_order_by
	variance: balances_transfer_variance_order_by
}

"""
input type for inserting array relation for remote table "squid_processor.transfer"
"""
input balances_transfer_arr_rel_insert_input {
	data: [balances_transfer_insert_input!]!

	"""
	upsert condition
	"""
	on_conflict: balances_transfer_on_conflict
}

"""
aggregate avg on columns
"""
type balances_transfer_avg_fields {
	amount: Float
	block_number: Float
}

"""
order by avg() on columns of table "squid_processor.transfer"
"""
input balances_transfer_avg_order_by {
	amount: order_by
	block_number: order_by
}

"""
Boolean expression to filter rows from the table "squid_processor.transfer". All fields are combined with a logical 'AND'.
"""
input balances_transfer_bool_exp {
	_and: [balances_transfer_bool_exp!]
	_not: balances_transfer_bool_exp
	_or: [balances_transfer_bool_exp!]
	account: balances_account_bool_exp
	accountByFromId: balances_account_bool_exp
	amount: numeric_comparison_exp
	asset_id: String_comparison_exp
	block_number: Int_comparison_exp
	extrinsic_hash: String_comparison_exp
	from_id: String_comparison_exp
	id: String_comparison_exp
	status: String_comparison_exp
	timestamp: timestamptz_comparison_exp
	to_id: String_comparison_exp
}

"""
unique or primary key constraints on table "squid_processor.transfer"
"""
enum balances_transfer_constraint {
	"""
	unique or primary key constraint on columns "id"
	"""
	PK_fd9ddbdd49a17afcbe014401295
}

"""
input type for incrementing numeric columns in table "squid_processor.transfer"
"""
input balances_transfer_inc_input {
	amount: numeric
	block_number: Int
}

"""
input type for inserting data into table "squid_processor.transfer"
"""
input balances_transfer_insert_input {
	account: balances_account_obj_rel_insert_input
	accountByFromId: balances_account_obj_rel_insert_input
	amount: numeric
	asset_id: String
	block_number: Int
	extrinsic_hash: String
	from_id: String
	id: String
	status: String
	timestamp: timestamptz
	to_id: String
}

"""
aggregate max on columns
"""
type balances_transfer_max_fields {
	amount: numeric
	asset_id: String
	block_number: Int
	extrinsic_hash: String
	from_id: String
	id: String
	status: String
	timestamp: timestamptz
	to_id: String
}

"""
order by max() on columns of table "squid_processor.transfer"
"""
input balances_transfer_max_order_by {
	amount: order_by
	asset_id: order_by
	block_number: order_by
	extrinsic_hash: order_by
	from_id: order_by
	id: order_by
	status: order_by
	timestamp: order_by
	to_id: order_by
}

"""
aggregate min on columns
"""
type balances_transfer_min_fields {
	amount: numeric
	asset_id: String
	block_number: Int
	extrinsic_hash: String
	from_id: String
	id: String
	status: String
	timestamp: timestamptz
	to_id: String
}

"""
order by min() on columns of table "squid_processor.transfer"
"""
input balances_transfer_min_order_by {
	amount: order_by
	asset_id: order_by
	block_number: order_by
	extrinsic_hash: order_by
	from_id: order_by
	id: order_by
	status: order_by
	timestamp: order_by
	to_id: order_by
}

"""
response of any mutation on the table "squid_processor.transfer"
"""
type balances_transfer_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!

	"""
	data from the rows affected by the mutation
	"""
	returning: [balances_transfer!]!
}

"""
on_conflict condition type for table "squid_processor.transfer"
"""
input balances_transfer_on_conflict {
	constraint: balances_transfer_constraint!
	update_columns: [balances_transfer_update_column!]! = []
	where: balances_transfer_bool_exp
}

"""
Ordering options when selecting data from "squid_processor.transfer".
"""
input balances_transfer_order_by {
	account: balances_account_order_by
	accountByFromId: balances_account_order_by
	amount: order_by
	asset_id: order_by
	block_number: order_by
	extrinsic_hash: order_by
	from_id: order_by
	id: order_by
	status: order_by
	timestamp: order_by
	to_id: order_by
}

"""
primary key columns input for table: transfer
"""
input balances_transfer_pk_columns_input {
	id: String!
}

"""
select columns of table "squid_processor.transfer"
"""
enum balances_transfer_select_column {
	"""
	column name
	"""
	amount

	"""
	column name
	"""
	asset_id

	"""
	column name
	"""
	block_number

	"""
	column name
	"""
	extrinsic_hash

	"""
	column name
	"""
	from_id

	"""
	column name
	"""
	id

	"""
	column name
	"""
	status

	"""
	column name
	"""
	timestamp

	"""
	column name
	"""
	to_id
}

"""
input type for updating data in table "squid_processor.transfer"
"""
input balances_transfer_set_input {
	amount: numeric
	asset_id: String
	block_number: Int
	extrinsic_hash: String
	from_id: String
	id: String
	status: String
	timestamp: timestamptz
	to_id: String
}

"""
aggregate stddev on columns
"""
type balances_transfer_stddev_fields {
	amount: Float
	block_number: Float
}

"""
order by stddev() on columns of table "squid_processor.transfer"
"""
input balances_transfer_stddev_order_by {
	amount: order_by
	block_number: order_by
}

"""
aggregate stddev_pop on columns
"""
type balances_transfer_stddev_pop_fields {
	amount: Float
	block_number: Float
}

"""
order by stddev_pop() on columns of table "squid_processor.transfer"
"""
input balances_transfer_stddev_pop_order_by {
	amount: order_by
	block_number: order_by
}

"""
aggregate stddev_samp on columns
"""
type balances_transfer_stddev_samp_fields {
	amount: Float
	block_number: Float
}

"""
order by stddev_samp() on columns of table "squid_processor.transfer"
"""
input balances_transfer_stddev_samp_order_by {
	amount: order_by
	block_number: order_by
}

"""
Streaming cursor of the table "transfer"
"""
input balances_transfer_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: balances_transfer_stream_cursor_value_input!

	"""
	cursor ordering
	"""
	ordering: balances_cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input balances_transfer_stream_cursor_value_input {
	amount: numeric
	asset_id: String
	block_number: Int
	extrinsic_hash: String
	from_id: String
	id: String
	status: String
	timestamp: timestamptz
	to_id: String
}

"""
aggregate sum on columns
"""
type balances_transfer_sum_fields {
	amount: numeric
	block_number: Int
}

"""
order by sum() on columns of table "squid_processor.transfer"
"""
input balances_transfer_sum_order_by {
	amount: order_by
	block_number: order_by
}

"""
update columns of table "squid_processor.transfer"
"""
enum balances_transfer_update_column {
	"""
	column name
	"""
	amount

	"""
	column name
	"""
	asset_id

	"""
	column name
	"""
	block_number

	"""
	column name
	"""
	extrinsic_hash

	"""
	column name
	"""
	from_id

	"""
	column name
	"""
	id

	"""
	column name
	"""
	status

	"""
	column name
	"""
	timestamp

	"""
	column name
	"""
	to_id
}

input balances_transfer_updates {
	"""
	increments the numeric columns with given value of the filtered values
	"""
	_inc: balances_transfer_inc_input

	"""
	sets the columns of the filtered rows to the given values
	"""
	_set: balances_transfer_set_input
	where: balances_transfer_bool_exp!
}

"""
aggregate var_pop on columns
"""
type balances_transfer_var_pop_fields {
	amount: Float
	block_number: Float
}

"""
order by var_pop() on columns of table "squid_processor.transfer"
"""
input balances_transfer_var_pop_order_by {
	amount: order_by
	block_number: order_by
}

"""
aggregate var_samp on columns
"""
type balances_transfer_var_samp_fields {
	amount: Float
	block_number: Float
}

"""
order by var_samp() on columns of table "squid_processor.transfer"
"""
input balances_transfer_var_samp_order_by {
	amount: order_by
	block_number: order_by
}

"""
aggregate variance on columns
"""
type balances_transfer_variance_fields {
	amount: Float
	block_number: Float
}

"""
order by variance() on columns of table "squid_processor.transfer"
"""
input balances_transfer_variance_order_by {
	amount: order_by
	block_number: order_by
}

scalar bpchar

"""
Boolean expression to compare columns of type "bpchar". All fields are combined with logical 'AND'.
"""
input bpchar_comparison_exp {
	_eq: bpchar
	_gt: bpchar
	_gte: bpchar

	"""
	does the column match the given case-insensitive pattern
	"""
	_ilike: bpchar
	_in: [bpchar!]

	"""
	does the column match the given POSIX regular expression, case insensitive
	"""
	_iregex: bpchar
	_is_null: Boolean

	"""
	does the column match the given pattern
	"""
	_like: bpchar
	_lt: bpchar
	_lte: bpchar
	_neq: bpchar

	"""
	does the column NOT match the given case-insensitive pattern
	"""
	_nilike: bpchar
	_nin: [bpchar!]

	"""
	does the column NOT match the given POSIX regular expression, case insensitive
	"""
	_niregex: bpchar

	"""
	does the column NOT match the given pattern
	"""
	_nlike: bpchar

	"""
	does the column NOT match the given POSIX regular expression, case sensitive
	"""
	_nregex: bpchar

	"""
	does the column NOT match the given SQL regular expression
	"""
	_nsimilar: bpchar

	"""
	does the column match the given POSIX regular expression, case sensitive
	"""
	_regex: bpchar

	"""
	does the column match the given SQL regular expression
	"""
	_similar: bpchar
}

"""
columns and relationships of "squid_erc.account"
"""
type erc_account {
	"""
	An array relationship
	"""
	account_f_token_balances(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_account_f_token_balance_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_account_f_token_balance_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_account_f_token_balance_bool_exp
	): [erc_account_f_token_balance!]!

	"""
	An aggregate relationship
	"""
	account_f_token_balances_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_account_f_token_balance_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_account_f_token_balance_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_account_f_token_balance_bool_exp
	): erc_account_f_token_balance_aggregate!

	"""
	An array relationship
	"""
	account_ft_transfers(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_account_ft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_account_ft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_account_ft_transfer_bool_exp
	): [erc_account_ft_transfer!]!

	"""
	An aggregate relationship
	"""
	account_ft_transfers_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_account_ft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_account_ft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_account_ft_transfer_bool_exp
	): erc_account_ft_transfer_aggregate!

	"""
	An array relationship
	"""
	account_nft_transfers(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_account_nft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_account_nft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_account_nft_transfer_bool_exp
	): [erc_account_nft_transfer!]!

	"""
	An aggregate relationship
	"""
	account_nft_transfers_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_account_nft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_account_nft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_account_nft_transfer_bool_exp
	): erc_account_nft_transfer_aggregate!

	"""
	An array relationship
	"""
	ftTransfersByToId(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_ft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_ft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_ft_transfer_bool_exp
	): [erc_ft_transfer!]!

	"""
	An aggregate relationship
	"""
	ftTransfersByToId_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_ft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_ft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_ft_transfer_bool_exp
	): erc_ft_transfer_aggregate!

	"""
	An array relationship
	"""
	ft_transfers(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_ft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_ft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_ft_transfer_bool_exp
	): [erc_ft_transfer!]!

	"""
	An aggregate relationship
	"""
	ft_transfers_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_ft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_ft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_ft_transfer_bool_exp
	): erc_ft_transfer_aggregate!
	id: String!

	"""
	An array relationship
	"""
	nf_tokens(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_nf_token_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_nf_token_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_nf_token_bool_exp
	): [erc_nf_token!]!

	"""
	An aggregate relationship
	"""
	nf_tokens_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_nf_token_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_nf_token_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_nf_token_bool_exp
	): erc_nf_token_aggregate!

	"""
	An array relationship
	"""
	nftTransfersByFromId(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_nft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_nft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_nft_transfer_bool_exp
	): [erc_nft_transfer!]!

	"""
	An aggregate relationship
	"""
	nftTransfersByFromId_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_nft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_nft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_nft_transfer_bool_exp
	): erc_nft_transfer_aggregate!

	"""
	An array relationship
	"""
	nftTransfersByToId(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_nft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_nft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_nft_transfer_bool_exp
	): [erc_nft_transfer!]!

	"""
	An aggregate relationship
	"""
	nftTransfersByToId_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_nft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_nft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_nft_transfer_bool_exp
	): erc_nft_transfer_aggregate!

	"""
	An array relationship
	"""
	nft_transfers(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_nft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_nft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_nft_transfer_bool_exp
	): [erc_nft_transfer!]!

	"""
	An aggregate relationship
	"""
	nft_transfers_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_nft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_nft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_nft_transfer_bool_exp
	): erc_nft_transfer_aggregate!
}

"""
aggregated selection of "squid_erc.account"
"""
type erc_account_aggregate {
	aggregate: erc_account_aggregate_fields
	nodes: [erc_account!]!
}

"""
aggregate fields of "squid_erc.account"
"""
type erc_account_aggregate_fields {
	count(columns: [erc_account_select_column!], distinct: Boolean): Int!
	max: erc_account_max_fields
	min: erc_account_min_fields
}

"""
Boolean expression to filter rows from the table "squid_erc.account". All fields are combined with a logical 'AND'.
"""
input erc_account_bool_exp {
	_and: [erc_account_bool_exp!]
	_not: erc_account_bool_exp
	_or: [erc_account_bool_exp!]
	account_f_token_balances: erc_account_f_token_balance_bool_exp
	account_ft_transfers: erc_account_ft_transfer_bool_exp
	account_nft_transfers: erc_account_nft_transfer_bool_exp
	ftTransfersByToId: erc_ft_transfer_bool_exp
	ft_transfers: erc_ft_transfer_bool_exp
	id: String_comparison_exp
	nf_tokens: erc_nf_token_bool_exp
	nftTransfersByFromId: erc_nft_transfer_bool_exp
	nftTransfersByToId: erc_nft_transfer_bool_exp
	nft_transfers: erc_nft_transfer_bool_exp
}

"""
unique or primary key constraints on table "squid_erc.account"
"""
enum erc_account_constraint {
	"""
	unique or primary key constraint on columns "id"
	"""
	PK_54115ee388cdb6d86bb4bf5b2ea
}

"""
columns and relationships of "squid_erc.account_f_token_balance"
"""
type erc_account_f_token_balance {
	"""
	An object relationship
	"""
	account: erc_account!
	account_id: String!
	amount: numeric!

	"""
	An object relationship
	"""
	f_token: erc_f_token!
	id: String!
	token_id: String!
	updated_at: timestamptz!
	updated_at_block: numeric!
}

"""
aggregated selection of "squid_erc.account_f_token_balance"
"""
type erc_account_f_token_balance_aggregate {
	aggregate: erc_account_f_token_balance_aggregate_fields
	nodes: [erc_account_f_token_balance!]!
}

"""
aggregate fields of "squid_erc.account_f_token_balance"
"""
type erc_account_f_token_balance_aggregate_fields {
	avg: erc_account_f_token_balance_avg_fields
	count(
		columns: [erc_account_f_token_balance_select_column!]
		distinct: Boolean
	): Int!
	max: erc_account_f_token_balance_max_fields
	min: erc_account_f_token_balance_min_fields
	stddev: erc_account_f_token_balance_stddev_fields
	stddev_pop: erc_account_f_token_balance_stddev_pop_fields
	stddev_samp: erc_account_f_token_balance_stddev_samp_fields
	sum: erc_account_f_token_balance_sum_fields
	var_pop: erc_account_f_token_balance_var_pop_fields
	var_samp: erc_account_f_token_balance_var_samp_fields
	variance: erc_account_f_token_balance_variance_fields
}

"""
order by aggregate values of table "squid_erc.account_f_token_balance"
"""
input erc_account_f_token_balance_aggregate_order_by {
	avg: erc_account_f_token_balance_avg_order_by
	count: order_by
	max: erc_account_f_token_balance_max_order_by
	min: erc_account_f_token_balance_min_order_by
	stddev: erc_account_f_token_balance_stddev_order_by
	stddev_pop: erc_account_f_token_balance_stddev_pop_order_by
	stddev_samp: erc_account_f_token_balance_stddev_samp_order_by
	sum: erc_account_f_token_balance_sum_order_by
	var_pop: erc_account_f_token_balance_var_pop_order_by
	var_samp: erc_account_f_token_balance_var_samp_order_by
	variance: erc_account_f_token_balance_variance_order_by
}

"""
input type for inserting array relation for remote table "squid_erc.account_f_token_balance"
"""
input erc_account_f_token_balance_arr_rel_insert_input {
	data: [erc_account_f_token_balance_insert_input!]!

	"""
	upsert condition
	"""
	on_conflict: erc_account_f_token_balance_on_conflict
}

"""
aggregate avg on columns
"""
type erc_account_f_token_balance_avg_fields {
	amount: Float
	updated_at_block: Float
}

"""
order by avg() on columns of table "squid_erc.account_f_token_balance"
"""
input erc_account_f_token_balance_avg_order_by {
	amount: order_by
	updated_at_block: order_by
}

"""
Boolean expression to filter rows from the table "squid_erc.account_f_token_balance". All fields are combined with a logical 'AND'.
"""
input erc_account_f_token_balance_bool_exp {
	_and: [erc_account_f_token_balance_bool_exp!]
	_not: erc_account_f_token_balance_bool_exp
	_or: [erc_account_f_token_balance_bool_exp!]
	account: erc_account_bool_exp
	account_id: String_comparison_exp
	amount: numeric_comparison_exp
	f_token: erc_f_token_bool_exp
	id: String_comparison_exp
	token_id: String_comparison_exp
	updated_at: timestamptz_comparison_exp
	updated_at_block: numeric_comparison_exp
}

"""
unique or primary key constraints on table "squid_erc.account_f_token_balance"
"""
enum erc_account_f_token_balance_constraint {
	"""
	unique or primary key constraint on columns "id"
	"""
	PK_c5ff211ac7ea9f25010a8ceab68
}

"""
input type for incrementing numeric columns in table "squid_erc.account_f_token_balance"
"""
input erc_account_f_token_balance_inc_input {
	amount: numeric
	updated_at_block: numeric
}

"""
input type for inserting data into table "squid_erc.account_f_token_balance"
"""
input erc_account_f_token_balance_insert_input {
	account: erc_account_obj_rel_insert_input
	account_id: String
	amount: numeric
	f_token: erc_f_token_obj_rel_insert_input
	id: String
	token_id: String
	updated_at: timestamptz
	updated_at_block: numeric
}

"""
aggregate max on columns
"""
type erc_account_f_token_balance_max_fields {
	account_id: String
	amount: numeric
	id: String
	token_id: String
	updated_at: timestamptz
	updated_at_block: numeric
}

"""
order by max() on columns of table "squid_erc.account_f_token_balance"
"""
input erc_account_f_token_balance_max_order_by {
	account_id: order_by
	amount: order_by
	id: order_by
	token_id: order_by
	updated_at: order_by
	updated_at_block: order_by
}

"""
aggregate min on columns
"""
type erc_account_f_token_balance_min_fields {
	account_id: String
	amount: numeric
	id: String
	token_id: String
	updated_at: timestamptz
	updated_at_block: numeric
}

"""
order by min() on columns of table "squid_erc.account_f_token_balance"
"""
input erc_account_f_token_balance_min_order_by {
	account_id: order_by
	amount: order_by
	id: order_by
	token_id: order_by
	updated_at: order_by
	updated_at_block: order_by
}

"""
response of any mutation on the table "squid_erc.account_f_token_balance"
"""
type erc_account_f_token_balance_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!

	"""
	data from the rows affected by the mutation
	"""
	returning: [erc_account_f_token_balance!]!
}

"""
on_conflict condition type for table "squid_erc.account_f_token_balance"
"""
input erc_account_f_token_balance_on_conflict {
	constraint: erc_account_f_token_balance_constraint!
	update_columns: [erc_account_f_token_balance_update_column!]! = []
	where: erc_account_f_token_balance_bool_exp
}

"""
Ordering options when selecting data from "squid_erc.account_f_token_balance".
"""
input erc_account_f_token_balance_order_by {
	account: erc_account_order_by
	account_id: order_by
	amount: order_by
	f_token: erc_f_token_order_by
	id: order_by
	token_id: order_by
	updated_at: order_by
	updated_at_block: order_by
}

"""
primary key columns input for table: account_f_token_balance
"""
input erc_account_f_token_balance_pk_columns_input {
	id: String!
}

"""
select columns of table "squid_erc.account_f_token_balance"
"""
enum erc_account_f_token_balance_select_column {
	"""
	column name
	"""
	account_id

	"""
	column name
	"""
	amount

	"""
	column name
	"""
	id

	"""
	column name
	"""
	token_id

	"""
	column name
	"""
	updated_at

	"""
	column name
	"""
	updated_at_block
}

"""
input type for updating data in table "squid_erc.account_f_token_balance"
"""
input erc_account_f_token_balance_set_input {
	account_id: String
	amount: numeric
	id: String
	token_id: String
	updated_at: timestamptz
	updated_at_block: numeric
}

"""
aggregate stddev on columns
"""
type erc_account_f_token_balance_stddev_fields {
	amount: Float
	updated_at_block: Float
}

"""
order by stddev() on columns of table "squid_erc.account_f_token_balance"
"""
input erc_account_f_token_balance_stddev_order_by {
	amount: order_by
	updated_at_block: order_by
}

"""
aggregate stddev_pop on columns
"""
type erc_account_f_token_balance_stddev_pop_fields {
	amount: Float
	updated_at_block: Float
}

"""
order by stddev_pop() on columns of table "squid_erc.account_f_token_balance"
"""
input erc_account_f_token_balance_stddev_pop_order_by {
	amount: order_by
	updated_at_block: order_by
}

"""
aggregate stddev_samp on columns
"""
type erc_account_f_token_balance_stddev_samp_fields {
	amount: Float
	updated_at_block: Float
}

"""
order by stddev_samp() on columns of table "squid_erc.account_f_token_balance"
"""
input erc_account_f_token_balance_stddev_samp_order_by {
	amount: order_by
	updated_at_block: order_by
}

"""
Streaming cursor of the table "account_f_token_balance"
"""
input erc_account_f_token_balance_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: erc_account_f_token_balance_stream_cursor_value_input!

	"""
	cursor ordering
	"""
	ordering: erc_cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input erc_account_f_token_balance_stream_cursor_value_input {
	account_id: String
	amount: numeric
	id: String
	token_id: String
	updated_at: timestamptz
	updated_at_block: numeric
}

"""
aggregate sum on columns
"""
type erc_account_f_token_balance_sum_fields {
	amount: numeric
	updated_at_block: numeric
}

"""
order by sum() on columns of table "squid_erc.account_f_token_balance"
"""
input erc_account_f_token_balance_sum_order_by {
	amount: order_by
	updated_at_block: order_by
}

"""
update columns of table "squid_erc.account_f_token_balance"
"""
enum erc_account_f_token_balance_update_column {
	"""
	column name
	"""
	account_id

	"""
	column name
	"""
	amount

	"""
	column name
	"""
	id

	"""
	column name
	"""
	token_id

	"""
	column name
	"""
	updated_at

	"""
	column name
	"""
	updated_at_block
}

input erc_account_f_token_balance_updates {
	"""
	increments the numeric columns with given value of the filtered values
	"""
	_inc: erc_account_f_token_balance_inc_input

	"""
	sets the columns of the filtered rows to the given values
	"""
	_set: erc_account_f_token_balance_set_input
	where: erc_account_f_token_balance_bool_exp!
}

"""
aggregate var_pop on columns
"""
type erc_account_f_token_balance_var_pop_fields {
	amount: Float
	updated_at_block: Float
}

"""
order by var_pop() on columns of table "squid_erc.account_f_token_balance"
"""
input erc_account_f_token_balance_var_pop_order_by {
	amount: order_by
	updated_at_block: order_by
}

"""
aggregate var_samp on columns
"""
type erc_account_f_token_balance_var_samp_fields {
	amount: Float
	updated_at_block: Float
}

"""
order by var_samp() on columns of table "squid_erc.account_f_token_balance"
"""
input erc_account_f_token_balance_var_samp_order_by {
	amount: order_by
	updated_at_block: order_by
}

"""
aggregate variance on columns
"""
type erc_account_f_token_balance_variance_fields {
	amount: Float
	updated_at_block: Float
}

"""
order by variance() on columns of table "squid_erc.account_f_token_balance"
"""
input erc_account_f_token_balance_variance_order_by {
	amount: order_by
	updated_at_block: order_by
}

"""
columns and relationships of "squid_erc.account_ft_transfer"
"""
type erc_account_ft_transfer {
	"""
	An object relationship
	"""
	account: erc_account!
	account_id: String!
	direction: String

	"""
	An object relationship
	"""
	ft_transfer: erc_ft_transfer
	id: String!
	transfer_id: String
}

"""
aggregated selection of "squid_erc.account_ft_transfer"
"""
type erc_account_ft_transfer_aggregate {
	aggregate: erc_account_ft_transfer_aggregate_fields
	nodes: [erc_account_ft_transfer!]!
}

"""
aggregate fields of "squid_erc.account_ft_transfer"
"""
type erc_account_ft_transfer_aggregate_fields {
	count(
		columns: [erc_account_ft_transfer_select_column!]
		distinct: Boolean
	): Int!
	max: erc_account_ft_transfer_max_fields
	min: erc_account_ft_transfer_min_fields
}

"""
order by aggregate values of table "squid_erc.account_ft_transfer"
"""
input erc_account_ft_transfer_aggregate_order_by {
	count: order_by
	max: erc_account_ft_transfer_max_order_by
	min: erc_account_ft_transfer_min_order_by
}

"""
input type for inserting array relation for remote table "squid_erc.account_ft_transfer"
"""
input erc_account_ft_transfer_arr_rel_insert_input {
	data: [erc_account_ft_transfer_insert_input!]!

	"""
	upsert condition
	"""
	on_conflict: erc_account_ft_transfer_on_conflict
}

"""
Boolean expression to filter rows from the table "squid_erc.account_ft_transfer". All fields are combined with a logical 'AND'.
"""
input erc_account_ft_transfer_bool_exp {
	_and: [erc_account_ft_transfer_bool_exp!]
	_not: erc_account_ft_transfer_bool_exp
	_or: [erc_account_ft_transfer_bool_exp!]
	account: erc_account_bool_exp
	account_id: String_comparison_exp
	direction: String_comparison_exp
	ft_transfer: erc_ft_transfer_bool_exp
	id: String_comparison_exp
	transfer_id: String_comparison_exp
}

"""
unique or primary key constraints on table "squid_erc.account_ft_transfer"
"""
enum erc_account_ft_transfer_constraint {
	"""
	unique or primary key constraint on columns "id"
	"""
	PK_c806d331df157e95bfc5c97dc77
}

"""
input type for inserting data into table "squid_erc.account_ft_transfer"
"""
input erc_account_ft_transfer_insert_input {
	account: erc_account_obj_rel_insert_input
	account_id: String
	direction: String
	ft_transfer: erc_ft_transfer_obj_rel_insert_input
	id: String
	transfer_id: String
}

"""
aggregate max on columns
"""
type erc_account_ft_transfer_max_fields {
	account_id: String
	direction: String
	id: String
	transfer_id: String
}

"""
order by max() on columns of table "squid_erc.account_ft_transfer"
"""
input erc_account_ft_transfer_max_order_by {
	account_id: order_by
	direction: order_by
	id: order_by
	transfer_id: order_by
}

"""
aggregate min on columns
"""
type erc_account_ft_transfer_min_fields {
	account_id: String
	direction: String
	id: String
	transfer_id: String
}

"""
order by min() on columns of table "squid_erc.account_ft_transfer"
"""
input erc_account_ft_transfer_min_order_by {
	account_id: order_by
	direction: order_by
	id: order_by
	transfer_id: order_by
}

"""
response of any mutation on the table "squid_erc.account_ft_transfer"
"""
type erc_account_ft_transfer_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!

	"""
	data from the rows affected by the mutation
	"""
	returning: [erc_account_ft_transfer!]!
}

"""
on_conflict condition type for table "squid_erc.account_ft_transfer"
"""
input erc_account_ft_transfer_on_conflict {
	constraint: erc_account_ft_transfer_constraint!
	update_columns: [erc_account_ft_transfer_update_column!]! = []
	where: erc_account_ft_transfer_bool_exp
}

"""
Ordering options when selecting data from "squid_erc.account_ft_transfer".
"""
input erc_account_ft_transfer_order_by {
	account: erc_account_order_by
	account_id: order_by
	direction: order_by
	ft_transfer: erc_ft_transfer_order_by
	id: order_by
	transfer_id: order_by
}

"""
primary key columns input for table: account_ft_transfer
"""
input erc_account_ft_transfer_pk_columns_input {
	id: String!
}

"""
select columns of table "squid_erc.account_ft_transfer"
"""
enum erc_account_ft_transfer_select_column {
	"""
	column name
	"""
	account_id

	"""
	column name
	"""
	direction

	"""
	column name
	"""
	id

	"""
	column name
	"""
	transfer_id
}

"""
input type for updating data in table "squid_erc.account_ft_transfer"
"""
input erc_account_ft_transfer_set_input {
	account_id: String
	direction: String
	id: String
	transfer_id: String
}

"""
Streaming cursor of the table "account_ft_transfer"
"""
input erc_account_ft_transfer_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: erc_account_ft_transfer_stream_cursor_value_input!

	"""
	cursor ordering
	"""
	ordering: erc_cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input erc_account_ft_transfer_stream_cursor_value_input {
	account_id: String
	direction: String
	id: String
	transfer_id: String
}

"""
update columns of table "squid_erc.account_ft_transfer"
"""
enum erc_account_ft_transfer_update_column {
	"""
	column name
	"""
	account_id

	"""
	column name
	"""
	direction

	"""
	column name
	"""
	id

	"""
	column name
	"""
	transfer_id
}

input erc_account_ft_transfer_updates {
	"""
	sets the columns of the filtered rows to the given values
	"""
	_set: erc_account_ft_transfer_set_input
	where: erc_account_ft_transfer_bool_exp!
}

"""
input type for inserting data into table "squid_erc.account"
"""
input erc_account_insert_input {
	account_f_token_balances: erc_account_f_token_balance_arr_rel_insert_input
	account_ft_transfers: erc_account_ft_transfer_arr_rel_insert_input
	account_nft_transfers: erc_account_nft_transfer_arr_rel_insert_input
	ftTransfersByToId: erc_ft_transfer_arr_rel_insert_input
	ft_transfers: erc_ft_transfer_arr_rel_insert_input
	id: String
	nf_tokens: erc_nf_token_arr_rel_insert_input
	nftTransfersByFromId: erc_nft_transfer_arr_rel_insert_input
	nftTransfersByToId: erc_nft_transfer_arr_rel_insert_input
	nft_transfers: erc_nft_transfer_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type erc_account_max_fields {
	id: String
}

"""
aggregate min on columns
"""
type erc_account_min_fields {
	id: String
}

"""
response of any mutation on the table "squid_erc.account"
"""
type erc_account_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!

	"""
	data from the rows affected by the mutation
	"""
	returning: [erc_account!]!
}

"""
columns and relationships of "squid_erc.account_nft_transfer"
"""
type erc_account_nft_transfer {
	"""
	An object relationship
	"""
	account: erc_account!
	account_id: String!
	direction: String
	id: String!

	"""
	An object relationship
	"""
	nft_transfer: erc_nft_transfer
	transfer_id: String
}

"""
aggregated selection of "squid_erc.account_nft_transfer"
"""
type erc_account_nft_transfer_aggregate {
	aggregate: erc_account_nft_transfer_aggregate_fields
	nodes: [erc_account_nft_transfer!]!
}

"""
aggregate fields of "squid_erc.account_nft_transfer"
"""
type erc_account_nft_transfer_aggregate_fields {
	count(
		columns: [erc_account_nft_transfer_select_column!]
		distinct: Boolean
	): Int!
	max: erc_account_nft_transfer_max_fields
	min: erc_account_nft_transfer_min_fields
}

"""
order by aggregate values of table "squid_erc.account_nft_transfer"
"""
input erc_account_nft_transfer_aggregate_order_by {
	count: order_by
	max: erc_account_nft_transfer_max_order_by
	min: erc_account_nft_transfer_min_order_by
}

"""
input type for inserting array relation for remote table "squid_erc.account_nft_transfer"
"""
input erc_account_nft_transfer_arr_rel_insert_input {
	data: [erc_account_nft_transfer_insert_input!]!

	"""
	upsert condition
	"""
	on_conflict: erc_account_nft_transfer_on_conflict
}

"""
Boolean expression to filter rows from the table "squid_erc.account_nft_transfer". All fields are combined with a logical 'AND'.
"""
input erc_account_nft_transfer_bool_exp {
	_and: [erc_account_nft_transfer_bool_exp!]
	_not: erc_account_nft_transfer_bool_exp
	_or: [erc_account_nft_transfer_bool_exp!]
	account: erc_account_bool_exp
	account_id: String_comparison_exp
	direction: String_comparison_exp
	id: String_comparison_exp
	nft_transfer: erc_nft_transfer_bool_exp
	transfer_id: String_comparison_exp
}

"""
unique or primary key constraints on table "squid_erc.account_nft_transfer"
"""
enum erc_account_nft_transfer_constraint {
	"""
	unique or primary key constraint on columns "id"
	"""
	PK_63cecb44d101ea1a54908c34a24
}

"""
input type for inserting data into table "squid_erc.account_nft_transfer"
"""
input erc_account_nft_transfer_insert_input {
	account: erc_account_obj_rel_insert_input
	account_id: String
	direction: String
	id: String
	nft_transfer: erc_nft_transfer_obj_rel_insert_input
	transfer_id: String
}

"""
aggregate max on columns
"""
type erc_account_nft_transfer_max_fields {
	account_id: String
	direction: String
	id: String
	transfer_id: String
}

"""
order by max() on columns of table "squid_erc.account_nft_transfer"
"""
input erc_account_nft_transfer_max_order_by {
	account_id: order_by
	direction: order_by
	id: order_by
	transfer_id: order_by
}

"""
aggregate min on columns
"""
type erc_account_nft_transfer_min_fields {
	account_id: String
	direction: String
	id: String
	transfer_id: String
}

"""
order by min() on columns of table "squid_erc.account_nft_transfer"
"""
input erc_account_nft_transfer_min_order_by {
	account_id: order_by
	direction: order_by
	id: order_by
	transfer_id: order_by
}

"""
response of any mutation on the table "squid_erc.account_nft_transfer"
"""
type erc_account_nft_transfer_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!

	"""
	data from the rows affected by the mutation
	"""
	returning: [erc_account_nft_transfer!]!
}

"""
on_conflict condition type for table "squid_erc.account_nft_transfer"
"""
input erc_account_nft_transfer_on_conflict {
	constraint: erc_account_nft_transfer_constraint!
	update_columns: [erc_account_nft_transfer_update_column!]! = []
	where: erc_account_nft_transfer_bool_exp
}

"""
Ordering options when selecting data from "squid_erc.account_nft_transfer".
"""
input erc_account_nft_transfer_order_by {
	account: erc_account_order_by
	account_id: order_by
	direction: order_by
	id: order_by
	nft_transfer: erc_nft_transfer_order_by
	transfer_id: order_by
}

"""
primary key columns input for table: account_nft_transfer
"""
input erc_account_nft_transfer_pk_columns_input {
	id: String!
}

"""
select columns of table "squid_erc.account_nft_transfer"
"""
enum erc_account_nft_transfer_select_column {
	"""
	column name
	"""
	account_id

	"""
	column name
	"""
	direction

	"""
	column name
	"""
	id

	"""
	column name
	"""
	transfer_id
}

"""
input type for updating data in table "squid_erc.account_nft_transfer"
"""
input erc_account_nft_transfer_set_input {
	account_id: String
	direction: String
	id: String
	transfer_id: String
}

"""
Streaming cursor of the table "account_nft_transfer"
"""
input erc_account_nft_transfer_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: erc_account_nft_transfer_stream_cursor_value_input!

	"""
	cursor ordering
	"""
	ordering: erc_cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input erc_account_nft_transfer_stream_cursor_value_input {
	account_id: String
	direction: String
	id: String
	transfer_id: String
}

"""
update columns of table "squid_erc.account_nft_transfer"
"""
enum erc_account_nft_transfer_update_column {
	"""
	column name
	"""
	account_id

	"""
	column name
	"""
	direction

	"""
	column name
	"""
	id

	"""
	column name
	"""
	transfer_id
}

input erc_account_nft_transfer_updates {
	"""
	sets the columns of the filtered rows to the given values
	"""
	_set: erc_account_nft_transfer_set_input
	where: erc_account_nft_transfer_bool_exp!
}

"""
input type for inserting object relation for remote table "squid_erc.account"
"""
input erc_account_obj_rel_insert_input {
	data: erc_account_insert_input!

	"""
	upsert condition
	"""
	on_conflict: erc_account_on_conflict
}

"""
on_conflict condition type for table "squid_erc.account"
"""
input erc_account_on_conflict {
	constraint: erc_account_constraint!
	update_columns: [erc_account_update_column!]! = []
	where: erc_account_bool_exp
}

"""
Ordering options when selecting data from "squid_erc.account".
"""
input erc_account_order_by {
	account_f_token_balances_aggregate: erc_account_f_token_balance_aggregate_order_by
	account_ft_transfers_aggregate: erc_account_ft_transfer_aggregate_order_by
	account_nft_transfers_aggregate: erc_account_nft_transfer_aggregate_order_by
	ftTransfersByToId_aggregate: erc_ft_transfer_aggregate_order_by
	ft_transfers_aggregate: erc_ft_transfer_aggregate_order_by
	id: order_by
	nf_tokens_aggregate: erc_nf_token_aggregate_order_by
	nftTransfersByFromId_aggregate: erc_nft_transfer_aggregate_order_by
	nftTransfersByToId_aggregate: erc_nft_transfer_aggregate_order_by
	nft_transfers_aggregate: erc_nft_transfer_aggregate_order_by
}

"""
primary key columns input for table: account
"""
input erc_account_pk_columns_input {
	id: String!
}

"""
select columns of table "squid_erc.account"
"""
enum erc_account_select_column {
	"""
	column name
	"""
	id
}

"""
input type for updating data in table "squid_erc.account"
"""
input erc_account_set_input {
	id: String
}

"""
Streaming cursor of the table "account"
"""
input erc_account_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: erc_account_stream_cursor_value_input!

	"""
	cursor ordering
	"""
	ordering: erc_cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input erc_account_stream_cursor_value_input {
	id: String
}

"""
update columns of table "squid_erc.account"
"""
enum erc_account_update_column {
	"""
	column name
	"""
	id
}

input erc_account_updates {
	"""
	sets the columns of the filtered rows to the given values
	"""
	_set: erc_account_set_input
	where: erc_account_bool_exp!
}

"""
columns and relationships of "squid_erc.collection"
"""
type erc_collection {
	collection_type: String!
	created_at: timestamptz!
	created_at_block: numeric!
	id: String!

	"""
	An array relationship
	"""
	nf_tokens(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_nf_token_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_nf_token_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_nf_token_bool_exp
	): [erc_nf_token!]!

	"""
	An aggregate relationship
	"""
	nf_tokens_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_nf_token_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_nf_token_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_nf_token_bool_exp
	): erc_nf_token_aggregate!
}

"""
aggregated selection of "squid_erc.collection"
"""
type erc_collection_aggregate {
	aggregate: erc_collection_aggregate_fields
	nodes: [erc_collection!]!
}

"""
aggregate fields of "squid_erc.collection"
"""
type erc_collection_aggregate_fields {
	avg: erc_collection_avg_fields
	count(columns: [erc_collection_select_column!], distinct: Boolean): Int!
	max: erc_collection_max_fields
	min: erc_collection_min_fields
	stddev: erc_collection_stddev_fields
	stddev_pop: erc_collection_stddev_pop_fields
	stddev_samp: erc_collection_stddev_samp_fields
	sum: erc_collection_sum_fields
	var_pop: erc_collection_var_pop_fields
	var_samp: erc_collection_var_samp_fields
	variance: erc_collection_variance_fields
}

"""
aggregate avg on columns
"""
type erc_collection_avg_fields {
	created_at_block: Float
}

"""
Boolean expression to filter rows from the table "squid_erc.collection". All fields are combined with a logical 'AND'.
"""
input erc_collection_bool_exp {
	_and: [erc_collection_bool_exp!]
	_not: erc_collection_bool_exp
	_or: [erc_collection_bool_exp!]
	collection_type: String_comparison_exp
	created_at: timestamptz_comparison_exp
	created_at_block: numeric_comparison_exp
	id: String_comparison_exp
	nf_tokens: erc_nf_token_bool_exp
}

"""
unique or primary key constraints on table "squid_erc.collection"
"""
enum erc_collection_constraint {
	"""
	unique or primary key constraint on columns "id"
	"""
	PK_ad3f485bbc99d875491f44d7c85
}

"""
input type for incrementing numeric columns in table "squid_erc.collection"
"""
input erc_collection_inc_input {
	created_at_block: numeric
}

"""
input type for inserting data into table "squid_erc.collection"
"""
input erc_collection_insert_input {
	collection_type: String
	created_at: timestamptz
	created_at_block: numeric
	id: String
	nf_tokens: erc_nf_token_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type erc_collection_max_fields {
	collection_type: String
	created_at: timestamptz
	created_at_block: numeric
	id: String
}

"""
aggregate min on columns
"""
type erc_collection_min_fields {
	collection_type: String
	created_at: timestamptz
	created_at_block: numeric
	id: String
}

"""
response of any mutation on the table "squid_erc.collection"
"""
type erc_collection_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!

	"""
	data from the rows affected by the mutation
	"""
	returning: [erc_collection!]!
}

"""
input type for inserting object relation for remote table "squid_erc.collection"
"""
input erc_collection_obj_rel_insert_input {
	data: erc_collection_insert_input!

	"""
	upsert condition
	"""
	on_conflict: erc_collection_on_conflict
}

"""
on_conflict condition type for table "squid_erc.collection"
"""
input erc_collection_on_conflict {
	constraint: erc_collection_constraint!
	update_columns: [erc_collection_update_column!]! = []
	where: erc_collection_bool_exp
}

"""
Ordering options when selecting data from "squid_erc.collection".
"""
input erc_collection_order_by {
	collection_type: order_by
	created_at: order_by
	created_at_block: order_by
	id: order_by
	nf_tokens_aggregate: erc_nf_token_aggregate_order_by
}

"""
primary key columns input for table: collection
"""
input erc_collection_pk_columns_input {
	id: String!
}

"""
select columns of table "squid_erc.collection"
"""
enum erc_collection_select_column {
	"""
	column name
	"""
	collection_type

	"""
	column name
	"""
	created_at

	"""
	column name
	"""
	created_at_block

	"""
	column name
	"""
	id
}

"""
input type for updating data in table "squid_erc.collection"
"""
input erc_collection_set_input {
	collection_type: String
	created_at: timestamptz
	created_at_block: numeric
	id: String
}

"""
aggregate stddev on columns
"""
type erc_collection_stddev_fields {
	created_at_block: Float
}

"""
aggregate stddev_pop on columns
"""
type erc_collection_stddev_pop_fields {
	created_at_block: Float
}

"""
aggregate stddev_samp on columns
"""
type erc_collection_stddev_samp_fields {
	created_at_block: Float
}

"""
Streaming cursor of the table "collection"
"""
input erc_collection_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: erc_collection_stream_cursor_value_input!

	"""
	cursor ordering
	"""
	ordering: erc_cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input erc_collection_stream_cursor_value_input {
	collection_type: String
	created_at: timestamptz
	created_at_block: numeric
	id: String
}

"""
aggregate sum on columns
"""
type erc_collection_sum_fields {
	created_at_block: numeric
}

"""
update columns of table "squid_erc.collection"
"""
enum erc_collection_update_column {
	"""
	column name
	"""
	collection_type

	"""
	column name
	"""
	created_at

	"""
	column name
	"""
	created_at_block

	"""
	column name
	"""
	id
}

input erc_collection_updates {
	"""
	increments the numeric columns with given value of the filtered values
	"""
	_inc: erc_collection_inc_input

	"""
	sets the columns of the filtered rows to the given values
	"""
	_set: erc_collection_set_input
	where: erc_collection_bool_exp!
}

"""
aggregate var_pop on columns
"""
type erc_collection_var_pop_fields {
	created_at_block: Float
}

"""
aggregate var_samp on columns
"""
type erc_collection_var_samp_fields {
	created_at_block: Float
}

"""
aggregate variance on columns
"""
type erc_collection_variance_fields {
	created_at_block: Float
}

"""
ordering argument of a cursor
"""
enum erc_cursor_ordering {
	"""
	ascending ordering of the cursor
	"""
	ASC

	"""
	descending ordering of the cursor
	"""
	DESC
}

type erc_erc_mutation_frontend {
	"""
	delete data from the table: "squid_erc.account"
	"""
	delete_account(
		"""
		filter the rows which have to be deleted
		"""
		where: erc_account_bool_exp!
	): erc_account_mutation_response

	"""
	delete single row from the table: "squid_erc.account"
	"""
	delete_account_by_pk(id: String!): erc_account

	"""
	delete data from the table: "squid_erc.account_f_token_balance"
	"""
	delete_account_f_token_balance(
		"""
		filter the rows which have to be deleted
		"""
		where: erc_account_f_token_balance_bool_exp!
	): erc_account_f_token_balance_mutation_response

	"""
	delete single row from the table: "squid_erc.account_f_token_balance"
	"""
	delete_account_f_token_balance_by_pk(id: String!): erc_account_f_token_balance

	"""
	delete data from the table: "squid_erc.account_ft_transfer"
	"""
	delete_account_ft_transfer(
		"""
		filter the rows which have to be deleted
		"""
		where: erc_account_ft_transfer_bool_exp!
	): erc_account_ft_transfer_mutation_response

	"""
	delete single row from the table: "squid_erc.account_ft_transfer"
	"""
	delete_account_ft_transfer_by_pk(id: String!): erc_account_ft_transfer

	"""
	delete data from the table: "squid_erc.account_nft_transfer"
	"""
	delete_account_nft_transfer(
		"""
		filter the rows which have to be deleted
		"""
		where: erc_account_nft_transfer_bool_exp!
	): erc_account_nft_transfer_mutation_response

	"""
	delete single row from the table: "squid_erc.account_nft_transfer"
	"""
	delete_account_nft_transfer_by_pk(id: String!): erc_account_nft_transfer

	"""
	delete data from the table: "squid_erc.collection"
	"""
	delete_collection(
		"""
		filter the rows which have to be deleted
		"""
		where: erc_collection_bool_exp!
	): erc_collection_mutation_response

	"""
	delete single row from the table: "squid_erc.collection"
	"""
	delete_collection_by_pk(id: String!): erc_collection

	"""
	delete data from the table: "squid_erc.f_token"
	"""
	delete_f_token(
		"""
		filter the rows which have to be deleted
		"""
		where: erc_f_token_bool_exp!
	): erc_f_token_mutation_response

	"""
	delete single row from the table: "squid_erc.f_token"
	"""
	delete_f_token_by_pk(id: String!): erc_f_token

	"""
	delete data from the table: "squid_erc.ft_transfer"
	"""
	delete_ft_transfer(
		"""
		filter the rows which have to be deleted
		"""
		where: erc_ft_transfer_bool_exp!
	): erc_ft_transfer_mutation_response

	"""
	delete single row from the table: "squid_erc.ft_transfer"
	"""
	delete_ft_transfer_by_pk(id: String!): erc_ft_transfer

	"""
	delete data from the table: "squid_erc.nf_token"
	"""
	delete_nf_token(
		"""
		filter the rows which have to be deleted
		"""
		where: erc_nf_token_bool_exp!
	): erc_nf_token_mutation_response

	"""
	delete single row from the table: "squid_erc.nf_token"
	"""
	delete_nf_token_by_pk(id: String!): erc_nf_token

	"""
	delete data from the table: "squid_erc.nft_transfer"
	"""
	delete_nft_transfer(
		"""
		filter the rows which have to be deleted
		"""
		where: erc_nft_transfer_bool_exp!
	): erc_nft_transfer_mutation_response

	"""
	delete single row from the table: "squid_erc.nft_transfer"
	"""
	delete_nft_transfer_by_pk(id: String!): erc_nft_transfer

	"""
	delete data from the table: "squid_erc.uri_update_action"
	"""
	delete_uri_update_action(
		"""
		filter the rows which have to be deleted
		"""
		where: erc_uri_update_action_bool_exp!
	): erc_uri_update_action_mutation_response

	"""
	delete single row from the table: "squid_erc.uri_update_action"
	"""
	delete_uri_update_action_by_pk(id: String!): erc_uri_update_action

	"""
	insert data into the table: "squid_erc.account"
	"""
	insert_account(
		"""
		the rows to be inserted
		"""
		objects: [erc_account_insert_input!]!

		"""
		upsert condition
		"""
		on_conflict: erc_account_on_conflict
	): erc_account_mutation_response

	"""
	insert data into the table: "squid_erc.account_f_token_balance"
	"""
	insert_account_f_token_balance(
		"""
		the rows to be inserted
		"""
		objects: [erc_account_f_token_balance_insert_input!]!

		"""
		upsert condition
		"""
		on_conflict: erc_account_f_token_balance_on_conflict
	): erc_account_f_token_balance_mutation_response

	"""
	insert a single row into the table: "squid_erc.account_f_token_balance"
	"""
	insert_account_f_token_balance_one(
		"""
		the row to be inserted
		"""
		object: erc_account_f_token_balance_insert_input!

		"""
		upsert condition
		"""
		on_conflict: erc_account_f_token_balance_on_conflict
	): erc_account_f_token_balance

	"""
	insert data into the table: "squid_erc.account_ft_transfer"
	"""
	insert_account_ft_transfer(
		"""
		the rows to be inserted
		"""
		objects: [erc_account_ft_transfer_insert_input!]!

		"""
		upsert condition
		"""
		on_conflict: erc_account_ft_transfer_on_conflict
	): erc_account_ft_transfer_mutation_response

	"""
	insert a single row into the table: "squid_erc.account_ft_transfer"
	"""
	insert_account_ft_transfer_one(
		"""
		the row to be inserted
		"""
		object: erc_account_ft_transfer_insert_input!

		"""
		upsert condition
		"""
		on_conflict: erc_account_ft_transfer_on_conflict
	): erc_account_ft_transfer

	"""
	insert data into the table: "squid_erc.account_nft_transfer"
	"""
	insert_account_nft_transfer(
		"""
		the rows to be inserted
		"""
		objects: [erc_account_nft_transfer_insert_input!]!

		"""
		upsert condition
		"""
		on_conflict: erc_account_nft_transfer_on_conflict
	): erc_account_nft_transfer_mutation_response

	"""
	insert a single row into the table: "squid_erc.account_nft_transfer"
	"""
	insert_account_nft_transfer_one(
		"""
		the row to be inserted
		"""
		object: erc_account_nft_transfer_insert_input!

		"""
		upsert condition
		"""
		on_conflict: erc_account_nft_transfer_on_conflict
	): erc_account_nft_transfer

	"""
	insert a single row into the table: "squid_erc.account"
	"""
	insert_account_one(
		"""
		the row to be inserted
		"""
		object: erc_account_insert_input!

		"""
		upsert condition
		"""
		on_conflict: erc_account_on_conflict
	): erc_account

	"""
	insert data into the table: "squid_erc.collection"
	"""
	insert_collection(
		"""
		the rows to be inserted
		"""
		objects: [erc_collection_insert_input!]!

		"""
		upsert condition
		"""
		on_conflict: erc_collection_on_conflict
	): erc_collection_mutation_response

	"""
	insert a single row into the table: "squid_erc.collection"
	"""
	insert_collection_one(
		"""
		the row to be inserted
		"""
		object: erc_collection_insert_input!

		"""
		upsert condition
		"""
		on_conflict: erc_collection_on_conflict
	): erc_collection

	"""
	insert data into the table: "squid_erc.f_token"
	"""
	insert_f_token(
		"""
		the rows to be inserted
		"""
		objects: [erc_f_token_insert_input!]!

		"""
		upsert condition
		"""
		on_conflict: erc_f_token_on_conflict
	): erc_f_token_mutation_response

	"""
	insert a single row into the table: "squid_erc.f_token"
	"""
	insert_f_token_one(
		"""
		the row to be inserted
		"""
		object: erc_f_token_insert_input!

		"""
		upsert condition
		"""
		on_conflict: erc_f_token_on_conflict
	): erc_f_token

	"""
	insert data into the table: "squid_erc.ft_transfer"
	"""
	insert_ft_transfer(
		"""
		the rows to be inserted
		"""
		objects: [erc_ft_transfer_insert_input!]!

		"""
		upsert condition
		"""
		on_conflict: erc_ft_transfer_on_conflict
	): erc_ft_transfer_mutation_response

	"""
	insert a single row into the table: "squid_erc.ft_transfer"
	"""
	insert_ft_transfer_one(
		"""
		the row to be inserted
		"""
		object: erc_ft_transfer_insert_input!

		"""
		upsert condition
		"""
		on_conflict: erc_ft_transfer_on_conflict
	): erc_ft_transfer

	"""
	insert data into the table: "squid_erc.nf_token"
	"""
	insert_nf_token(
		"""
		the rows to be inserted
		"""
		objects: [erc_nf_token_insert_input!]!

		"""
		upsert condition
		"""
		on_conflict: erc_nf_token_on_conflict
	): erc_nf_token_mutation_response

	"""
	insert a single row into the table: "squid_erc.nf_token"
	"""
	insert_nf_token_one(
		"""
		the row to be inserted
		"""
		object: erc_nf_token_insert_input!

		"""
		upsert condition
		"""
		on_conflict: erc_nf_token_on_conflict
	): erc_nf_token

	"""
	insert data into the table: "squid_erc.nft_transfer"
	"""
	insert_nft_transfer(
		"""
		the rows to be inserted
		"""
		objects: [erc_nft_transfer_insert_input!]!

		"""
		upsert condition
		"""
		on_conflict: erc_nft_transfer_on_conflict
	): erc_nft_transfer_mutation_response

	"""
	insert a single row into the table: "squid_erc.nft_transfer"
	"""
	insert_nft_transfer_one(
		"""
		the row to be inserted
		"""
		object: erc_nft_transfer_insert_input!

		"""
		upsert condition
		"""
		on_conflict: erc_nft_transfer_on_conflict
	): erc_nft_transfer

	"""
	insert data into the table: "squid_erc.uri_update_action"
	"""
	insert_uri_update_action(
		"""
		the rows to be inserted
		"""
		objects: [erc_uri_update_action_insert_input!]!

		"""
		upsert condition
		"""
		on_conflict: erc_uri_update_action_on_conflict
	): erc_uri_update_action_mutation_response

	"""
	insert a single row into the table: "squid_erc.uri_update_action"
	"""
	insert_uri_update_action_one(
		"""
		the row to be inserted
		"""
		object: erc_uri_update_action_insert_input!

		"""
		upsert condition
		"""
		on_conflict: erc_uri_update_action_on_conflict
	): erc_uri_update_action

	"""
	update data of the table: "squid_erc.account"
	"""
	update_account(
		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: erc_account_set_input

		"""
		filter the rows which have to be updated
		"""
		where: erc_account_bool_exp!
	): erc_account_mutation_response

	"""
	update single row of the table: "squid_erc.account"
	"""
	update_account_by_pk(
		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: erc_account_set_input
		pk_columns: erc_account_pk_columns_input!
	): erc_account

	"""
	update data of the table: "squid_erc.account_f_token_balance"
	"""
	update_account_f_token_balance(
		"""
		increments the numeric columns with given value of the filtered values
		"""
		_inc: erc_account_f_token_balance_inc_input

		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: erc_account_f_token_balance_set_input

		"""
		filter the rows which have to be updated
		"""
		where: erc_account_f_token_balance_bool_exp!
	): erc_account_f_token_balance_mutation_response

	"""
	update single row of the table: "squid_erc.account_f_token_balance"
	"""
	update_account_f_token_balance_by_pk(
		"""
		increments the numeric columns with given value of the filtered values
		"""
		_inc: erc_account_f_token_balance_inc_input

		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: erc_account_f_token_balance_set_input
		pk_columns: erc_account_f_token_balance_pk_columns_input!
	): erc_account_f_token_balance

	"""
	update multiples rows of table: "squid_erc.account_f_token_balance"
	"""
	update_account_f_token_balance_many(
		"""
		updates to execute, in order
		"""
		updates: [erc_account_f_token_balance_updates!]!
	): [erc_account_f_token_balance_mutation_response]

	"""
	update data of the table: "squid_erc.account_ft_transfer"
	"""
	update_account_ft_transfer(
		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: erc_account_ft_transfer_set_input

		"""
		filter the rows which have to be updated
		"""
		where: erc_account_ft_transfer_bool_exp!
	): erc_account_ft_transfer_mutation_response

	"""
	update single row of the table: "squid_erc.account_ft_transfer"
	"""
	update_account_ft_transfer_by_pk(
		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: erc_account_ft_transfer_set_input
		pk_columns: erc_account_ft_transfer_pk_columns_input!
	): erc_account_ft_transfer

	"""
	update multiples rows of table: "squid_erc.account_ft_transfer"
	"""
	update_account_ft_transfer_many(
		"""
		updates to execute, in order
		"""
		updates: [erc_account_ft_transfer_updates!]!
	): [erc_account_ft_transfer_mutation_response]

	"""
	update multiples rows of table: "squid_erc.account"
	"""
	update_account_many(
		"""
		updates to execute, in order
		"""
		updates: [erc_account_updates!]!
	): [erc_account_mutation_response]

	"""
	update data of the table: "squid_erc.account_nft_transfer"
	"""
	update_account_nft_transfer(
		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: erc_account_nft_transfer_set_input

		"""
		filter the rows which have to be updated
		"""
		where: erc_account_nft_transfer_bool_exp!
	): erc_account_nft_transfer_mutation_response

	"""
	update single row of the table: "squid_erc.account_nft_transfer"
	"""
	update_account_nft_transfer_by_pk(
		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: erc_account_nft_transfer_set_input
		pk_columns: erc_account_nft_transfer_pk_columns_input!
	): erc_account_nft_transfer

	"""
	update multiples rows of table: "squid_erc.account_nft_transfer"
	"""
	update_account_nft_transfer_many(
		"""
		updates to execute, in order
		"""
		updates: [erc_account_nft_transfer_updates!]!
	): [erc_account_nft_transfer_mutation_response]

	"""
	update data of the table: "squid_erc.collection"
	"""
	update_collection(
		"""
		increments the numeric columns with given value of the filtered values
		"""
		_inc: erc_collection_inc_input

		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: erc_collection_set_input

		"""
		filter the rows which have to be updated
		"""
		where: erc_collection_bool_exp!
	): erc_collection_mutation_response

	"""
	update single row of the table: "squid_erc.collection"
	"""
	update_collection_by_pk(
		"""
		increments the numeric columns with given value of the filtered values
		"""
		_inc: erc_collection_inc_input

		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: erc_collection_set_input
		pk_columns: erc_collection_pk_columns_input!
	): erc_collection

	"""
	update multiples rows of table: "squid_erc.collection"
	"""
	update_collection_many(
		"""
		updates to execute, in order
		"""
		updates: [erc_collection_updates!]!
	): [erc_collection_mutation_response]

	"""
	update data of the table: "squid_erc.f_token"
	"""
	update_f_token(
		"""
		increments the numeric columns with given value of the filtered values
		"""
		_inc: erc_f_token_inc_input

		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: erc_f_token_set_input

		"""
		filter the rows which have to be updated
		"""
		where: erc_f_token_bool_exp!
	): erc_f_token_mutation_response

	"""
	update single row of the table: "squid_erc.f_token"
	"""
	update_f_token_by_pk(
		"""
		increments the numeric columns with given value of the filtered values
		"""
		_inc: erc_f_token_inc_input

		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: erc_f_token_set_input
		pk_columns: erc_f_token_pk_columns_input!
	): erc_f_token

	"""
	update multiples rows of table: "squid_erc.f_token"
	"""
	update_f_token_many(
		"""
		updates to execute, in order
		"""
		updates: [erc_f_token_updates!]!
	): [erc_f_token_mutation_response]

	"""
	update data of the table: "squid_erc.ft_transfer"
	"""
	update_ft_transfer(
		"""
		increments the numeric columns with given value of the filtered values
		"""
		_inc: erc_ft_transfer_inc_input

		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: erc_ft_transfer_set_input

		"""
		filter the rows which have to be updated
		"""
		where: erc_ft_transfer_bool_exp!
	): erc_ft_transfer_mutation_response

	"""
	update single row of the table: "squid_erc.ft_transfer"
	"""
	update_ft_transfer_by_pk(
		"""
		increments the numeric columns with given value of the filtered values
		"""
		_inc: erc_ft_transfer_inc_input

		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: erc_ft_transfer_set_input
		pk_columns: erc_ft_transfer_pk_columns_input!
	): erc_ft_transfer

	"""
	update multiples rows of table: "squid_erc.ft_transfer"
	"""
	update_ft_transfer_many(
		"""
		updates to execute, in order
		"""
		updates: [erc_ft_transfer_updates!]!
	): [erc_ft_transfer_mutation_response]

	"""
	update data of the table: "squid_erc.nf_token"
	"""
	update_nf_token(
		"""
		increments the numeric columns with given value of the filtered values
		"""
		_inc: erc_nf_token_inc_input

		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: erc_nf_token_set_input

		"""
		filter the rows which have to be updated
		"""
		where: erc_nf_token_bool_exp!
	): erc_nf_token_mutation_response

	"""
	update single row of the table: "squid_erc.nf_token"
	"""
	update_nf_token_by_pk(
		"""
		increments the numeric columns with given value of the filtered values
		"""
		_inc: erc_nf_token_inc_input

		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: erc_nf_token_set_input
		pk_columns: erc_nf_token_pk_columns_input!
	): erc_nf_token

	"""
	update multiples rows of table: "squid_erc.nf_token"
	"""
	update_nf_token_many(
		"""
		updates to execute, in order
		"""
		updates: [erc_nf_token_updates!]!
	): [erc_nf_token_mutation_response]

	"""
	update data of the table: "squid_erc.nft_transfer"
	"""
	update_nft_transfer(
		"""
		increments the numeric columns with given value of the filtered values
		"""
		_inc: erc_nft_transfer_inc_input

		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: erc_nft_transfer_set_input

		"""
		filter the rows which have to be updated
		"""
		where: erc_nft_transfer_bool_exp!
	): erc_nft_transfer_mutation_response

	"""
	update single row of the table: "squid_erc.nft_transfer"
	"""
	update_nft_transfer_by_pk(
		"""
		increments the numeric columns with given value of the filtered values
		"""
		_inc: erc_nft_transfer_inc_input

		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: erc_nft_transfer_set_input
		pk_columns: erc_nft_transfer_pk_columns_input!
	): erc_nft_transfer

	"""
	update multiples rows of table: "squid_erc.nft_transfer"
	"""
	update_nft_transfer_many(
		"""
		updates to execute, in order
		"""
		updates: [erc_nft_transfer_updates!]!
	): [erc_nft_transfer_mutation_response]

	"""
	update data of the table: "squid_erc.uri_update_action"
	"""
	update_uri_update_action(
		"""
		increments the numeric columns with given value of the filtered values
		"""
		_inc: erc_uri_update_action_inc_input

		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: erc_uri_update_action_set_input

		"""
		filter the rows which have to be updated
		"""
		where: erc_uri_update_action_bool_exp!
	): erc_uri_update_action_mutation_response

	"""
	update single row of the table: "squid_erc.uri_update_action"
	"""
	update_uri_update_action_by_pk(
		"""
		increments the numeric columns with given value of the filtered values
		"""
		_inc: erc_uri_update_action_inc_input

		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: erc_uri_update_action_set_input
		pk_columns: erc_uri_update_action_pk_columns_input!
	): erc_uri_update_action

	"""
	update multiples rows of table: "squid_erc.uri_update_action"
	"""
	update_uri_update_action_many(
		"""
		updates to execute, in order
		"""
		updates: [erc_uri_update_action_updates!]!
	): [erc_uri_update_action_mutation_response]
}

type erc_erc_query {
	"""
	fetch data from the table: "squid_erc.account"
	"""
	account(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_account_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_account_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_account_bool_exp
	): [erc_account!]!

	"""
	fetch aggregated fields from the table: "squid_erc.account"
	"""
	account_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_account_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_account_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_account_bool_exp
	): erc_account_aggregate!

	"""
	fetch data from the table: "squid_erc.account" using primary key columns
	"""
	account_by_pk(id: String!): erc_account

	"""
	fetch data from the table: "squid_erc.account_f_token_balance"
	"""
	account_f_token_balance(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_account_f_token_balance_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_account_f_token_balance_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_account_f_token_balance_bool_exp
	): [erc_account_f_token_balance!]!

	"""
	fetch aggregated fields from the table: "squid_erc.account_f_token_balance"
	"""
	account_f_token_balance_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_account_f_token_balance_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_account_f_token_balance_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_account_f_token_balance_bool_exp
	): erc_account_f_token_balance_aggregate!

	"""
	fetch data from the table: "squid_erc.account_f_token_balance" using primary key columns
	"""
	account_f_token_balance_by_pk(id: String!): erc_account_f_token_balance

	"""
	fetch data from the table: "squid_erc.account_ft_transfer"
	"""
	account_ft_transfer(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_account_ft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_account_ft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_account_ft_transfer_bool_exp
	): [erc_account_ft_transfer!]!

	"""
	fetch aggregated fields from the table: "squid_erc.account_ft_transfer"
	"""
	account_ft_transfer_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_account_ft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_account_ft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_account_ft_transfer_bool_exp
	): erc_account_ft_transfer_aggregate!

	"""
	fetch data from the table: "squid_erc.account_ft_transfer" using primary key columns
	"""
	account_ft_transfer_by_pk(id: String!): erc_account_ft_transfer

	"""
	fetch data from the table: "squid_erc.account_nft_transfer"
	"""
	account_nft_transfer(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_account_nft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_account_nft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_account_nft_transfer_bool_exp
	): [erc_account_nft_transfer!]!

	"""
	fetch aggregated fields from the table: "squid_erc.account_nft_transfer"
	"""
	account_nft_transfer_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_account_nft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_account_nft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_account_nft_transfer_bool_exp
	): erc_account_nft_transfer_aggregate!

	"""
	fetch data from the table: "squid_erc.account_nft_transfer" using primary key columns
	"""
	account_nft_transfer_by_pk(id: String!): erc_account_nft_transfer

	"""
	fetch data from the table: "squid_erc.collection"
	"""
	collection(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_collection_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_collection_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_collection_bool_exp
	): [erc_collection!]!

	"""
	fetch aggregated fields from the table: "squid_erc.collection"
	"""
	collection_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_collection_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_collection_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_collection_bool_exp
	): erc_collection_aggregate!

	"""
	fetch data from the table: "squid_erc.collection" using primary key columns
	"""
	collection_by_pk(id: String!): erc_collection

	"""
	fetch data from the table: "squid_erc.f_token"
	"""
	f_token(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_f_token_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_f_token_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_f_token_bool_exp
	): [erc_f_token!]!

	"""
	fetch aggregated fields from the table: "squid_erc.f_token"
	"""
	f_token_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_f_token_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_f_token_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_f_token_bool_exp
	): erc_f_token_aggregate!

	"""
	fetch data from the table: "squid_erc.f_token" using primary key columns
	"""
	f_token_by_pk(id: String!): erc_f_token

	"""
	fetch data from the table: "squid_erc.ft_transfer"
	"""
	ft_transfer(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_ft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_ft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_ft_transfer_bool_exp
	): [erc_ft_transfer!]!

	"""
	fetch aggregated fields from the table: "squid_erc.ft_transfer"
	"""
	ft_transfer_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_ft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_ft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_ft_transfer_bool_exp
	): erc_ft_transfer_aggregate!

	"""
	fetch data from the table: "squid_erc.ft_transfer" using primary key columns
	"""
	ft_transfer_by_pk(id: String!): erc_ft_transfer

	"""
	fetch data from the table: "squid_erc.nf_token"
	"""
	nf_token(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_nf_token_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_nf_token_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_nf_token_bool_exp
	): [erc_nf_token!]!

	"""
	fetch aggregated fields from the table: "squid_erc.nf_token"
	"""
	nf_token_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_nf_token_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_nf_token_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_nf_token_bool_exp
	): erc_nf_token_aggregate!

	"""
	fetch data from the table: "squid_erc.nf_token" using primary key columns
	"""
	nf_token_by_pk(id: String!): erc_nf_token

	"""
	fetch data from the table: "squid_erc.nft_transfer"
	"""
	nft_transfer(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_nft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_nft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_nft_transfer_bool_exp
	): [erc_nft_transfer!]!

	"""
	fetch aggregated fields from the table: "squid_erc.nft_transfer"
	"""
	nft_transfer_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_nft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_nft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_nft_transfer_bool_exp
	): erc_nft_transfer_aggregate!

	"""
	fetch data from the table: "squid_erc.nft_transfer" using primary key columns
	"""
	nft_transfer_by_pk(id: String!): erc_nft_transfer

	"""
	fetch data from the table: "squid_erc.uri_update_action"
	"""
	uri_update_action(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_uri_update_action_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_uri_update_action_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_uri_update_action_bool_exp
	): [erc_uri_update_action!]!

	"""
	fetch aggregated fields from the table: "squid_erc.uri_update_action"
	"""
	uri_update_action_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_uri_update_action_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_uri_update_action_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_uri_update_action_bool_exp
	): erc_uri_update_action_aggregate!

	"""
	fetch data from the table: "squid_erc.uri_update_action" using primary key columns
	"""
	uri_update_action_by_pk(id: String!): erc_uri_update_action
}

type erc_erc_subscription {
	"""
	fetch data from the table: "squid_erc.account"
	"""
	account(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_account_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_account_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_account_bool_exp
	): [erc_account!]!

	"""
	fetch aggregated fields from the table: "squid_erc.account"
	"""
	account_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_account_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_account_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_account_bool_exp
	): erc_account_aggregate!

	"""
	fetch data from the table: "squid_erc.account" using primary key columns
	"""
	account_by_pk(id: String!): erc_account

	"""
	fetch data from the table: "squid_erc.account_f_token_balance"
	"""
	account_f_token_balance(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_account_f_token_balance_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_account_f_token_balance_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_account_f_token_balance_bool_exp
	): [erc_account_f_token_balance!]!

	"""
	fetch aggregated fields from the table: "squid_erc.account_f_token_balance"
	"""
	account_f_token_balance_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_account_f_token_balance_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_account_f_token_balance_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_account_f_token_balance_bool_exp
	): erc_account_f_token_balance_aggregate!

	"""
	fetch data from the table: "squid_erc.account_f_token_balance" using primary key columns
	"""
	account_f_token_balance_by_pk(id: String!): erc_account_f_token_balance

	"""
	fetch data from the table in a streaming manner : "squid_erc.account_f_token_balance"
	"""
	account_f_token_balance_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!

		"""
		cursor to stream the results returned by the query
		"""
		cursor: [erc_account_f_token_balance_stream_cursor_input]!

		"""
		filter the rows returned
		"""
		where: erc_account_f_token_balance_bool_exp
	): [erc_account_f_token_balance!]!

	"""
	fetch data from the table: "squid_erc.account_ft_transfer"
	"""
	account_ft_transfer(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_account_ft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_account_ft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_account_ft_transfer_bool_exp
	): [erc_account_ft_transfer!]!

	"""
	fetch aggregated fields from the table: "squid_erc.account_ft_transfer"
	"""
	account_ft_transfer_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_account_ft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_account_ft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_account_ft_transfer_bool_exp
	): erc_account_ft_transfer_aggregate!

	"""
	fetch data from the table: "squid_erc.account_ft_transfer" using primary key columns
	"""
	account_ft_transfer_by_pk(id: String!): erc_account_ft_transfer

	"""
	fetch data from the table in a streaming manner : "squid_erc.account_ft_transfer"
	"""
	account_ft_transfer_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!

		"""
		cursor to stream the results returned by the query
		"""
		cursor: [erc_account_ft_transfer_stream_cursor_input]!

		"""
		filter the rows returned
		"""
		where: erc_account_ft_transfer_bool_exp
	): [erc_account_ft_transfer!]!

	"""
	fetch data from the table: "squid_erc.account_nft_transfer"
	"""
	account_nft_transfer(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_account_nft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_account_nft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_account_nft_transfer_bool_exp
	): [erc_account_nft_transfer!]!

	"""
	fetch aggregated fields from the table: "squid_erc.account_nft_transfer"
	"""
	account_nft_transfer_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_account_nft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_account_nft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_account_nft_transfer_bool_exp
	): erc_account_nft_transfer_aggregate!

	"""
	fetch data from the table: "squid_erc.account_nft_transfer" using primary key columns
	"""
	account_nft_transfer_by_pk(id: String!): erc_account_nft_transfer

	"""
	fetch data from the table in a streaming manner : "squid_erc.account_nft_transfer"
	"""
	account_nft_transfer_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!

		"""
		cursor to stream the results returned by the query
		"""
		cursor: [erc_account_nft_transfer_stream_cursor_input]!

		"""
		filter the rows returned
		"""
		where: erc_account_nft_transfer_bool_exp
	): [erc_account_nft_transfer!]!

	"""
	fetch data from the table in a streaming manner : "squid_erc.account"
	"""
	account_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!

		"""
		cursor to stream the results returned by the query
		"""
		cursor: [erc_account_stream_cursor_input]!

		"""
		filter the rows returned
		"""
		where: erc_account_bool_exp
	): [erc_account!]!

	"""
	fetch data from the table: "squid_erc.collection"
	"""
	collection(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_collection_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_collection_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_collection_bool_exp
	): [erc_collection!]!

	"""
	fetch aggregated fields from the table: "squid_erc.collection"
	"""
	collection_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_collection_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_collection_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_collection_bool_exp
	): erc_collection_aggregate!

	"""
	fetch data from the table: "squid_erc.collection" using primary key columns
	"""
	collection_by_pk(id: String!): erc_collection

	"""
	fetch data from the table in a streaming manner : "squid_erc.collection"
	"""
	collection_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!

		"""
		cursor to stream the results returned by the query
		"""
		cursor: [erc_collection_stream_cursor_input]!

		"""
		filter the rows returned
		"""
		where: erc_collection_bool_exp
	): [erc_collection!]!

	"""
	fetch data from the table: "squid_erc.f_token"
	"""
	f_token(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_f_token_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_f_token_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_f_token_bool_exp
	): [erc_f_token!]!

	"""
	fetch aggregated fields from the table: "squid_erc.f_token"
	"""
	f_token_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_f_token_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_f_token_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_f_token_bool_exp
	): erc_f_token_aggregate!

	"""
	fetch data from the table: "squid_erc.f_token" using primary key columns
	"""
	f_token_by_pk(id: String!): erc_f_token

	"""
	fetch data from the table in a streaming manner : "squid_erc.f_token"
	"""
	f_token_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!

		"""
		cursor to stream the results returned by the query
		"""
		cursor: [erc_f_token_stream_cursor_input]!

		"""
		filter the rows returned
		"""
		where: erc_f_token_bool_exp
	): [erc_f_token!]!

	"""
	fetch data from the table: "squid_erc.ft_transfer"
	"""
	ft_transfer(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_ft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_ft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_ft_transfer_bool_exp
	): [erc_ft_transfer!]!

	"""
	fetch aggregated fields from the table: "squid_erc.ft_transfer"
	"""
	ft_transfer_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_ft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_ft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_ft_transfer_bool_exp
	): erc_ft_transfer_aggregate!

	"""
	fetch data from the table: "squid_erc.ft_transfer" using primary key columns
	"""
	ft_transfer_by_pk(id: String!): erc_ft_transfer

	"""
	fetch data from the table in a streaming manner : "squid_erc.ft_transfer"
	"""
	ft_transfer_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!

		"""
		cursor to stream the results returned by the query
		"""
		cursor: [erc_ft_transfer_stream_cursor_input]!

		"""
		filter the rows returned
		"""
		where: erc_ft_transfer_bool_exp
	): [erc_ft_transfer!]!

	"""
	fetch data from the table: "squid_erc.nf_token"
	"""
	nf_token(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_nf_token_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_nf_token_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_nf_token_bool_exp
	): [erc_nf_token!]!

	"""
	fetch aggregated fields from the table: "squid_erc.nf_token"
	"""
	nf_token_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_nf_token_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_nf_token_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_nf_token_bool_exp
	): erc_nf_token_aggregate!

	"""
	fetch data from the table: "squid_erc.nf_token" using primary key columns
	"""
	nf_token_by_pk(id: String!): erc_nf_token

	"""
	fetch data from the table in a streaming manner : "squid_erc.nf_token"
	"""
	nf_token_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!

		"""
		cursor to stream the results returned by the query
		"""
		cursor: [erc_nf_token_stream_cursor_input]!

		"""
		filter the rows returned
		"""
		where: erc_nf_token_bool_exp
	): [erc_nf_token!]!

	"""
	fetch data from the table: "squid_erc.nft_transfer"
	"""
	nft_transfer(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_nft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_nft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_nft_transfer_bool_exp
	): [erc_nft_transfer!]!

	"""
	fetch aggregated fields from the table: "squid_erc.nft_transfer"
	"""
	nft_transfer_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_nft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_nft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_nft_transfer_bool_exp
	): erc_nft_transfer_aggregate!

	"""
	fetch data from the table: "squid_erc.nft_transfer" using primary key columns
	"""
	nft_transfer_by_pk(id: String!): erc_nft_transfer

	"""
	fetch data from the table in a streaming manner : "squid_erc.nft_transfer"
	"""
	nft_transfer_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!

		"""
		cursor to stream the results returned by the query
		"""
		cursor: [erc_nft_transfer_stream_cursor_input]!

		"""
		filter the rows returned
		"""
		where: erc_nft_transfer_bool_exp
	): [erc_nft_transfer!]!

	"""
	fetch data from the table: "squid_erc.uri_update_action"
	"""
	uri_update_action(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_uri_update_action_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_uri_update_action_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_uri_update_action_bool_exp
	): [erc_uri_update_action!]!

	"""
	fetch aggregated fields from the table: "squid_erc.uri_update_action"
	"""
	uri_update_action_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_uri_update_action_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_uri_update_action_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_uri_update_action_bool_exp
	): erc_uri_update_action_aggregate!

	"""
	fetch data from the table: "squid_erc.uri_update_action" using primary key columns
	"""
	uri_update_action_by_pk(id: String!): erc_uri_update_action

	"""
	fetch data from the table in a streaming manner : "squid_erc.uri_update_action"
	"""
	uri_update_action_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!

		"""
		cursor to stream the results returned by the query
		"""
		cursor: [erc_uri_update_action_stream_cursor_input]!

		"""
		filter the rows returned
		"""
		where: erc_uri_update_action_bool_exp
	): [erc_uri_update_action!]!
}

"""
columns and relationships of "squid_erc.f_token"
"""
type erc_f_token {
	"""
	An array relationship
	"""
	account_f_token_balances(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_account_f_token_balance_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_account_f_token_balance_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_account_f_token_balance_bool_exp
	): [erc_account_f_token_balance!]!

	"""
	An aggregate relationship
	"""
	account_f_token_balances_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_account_f_token_balance_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_account_f_token_balance_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_account_f_token_balance_bool_exp
	): erc_account_f_token_balance_aggregate!
	decimals: Int

	"""
	An array relationship
	"""
	ft_transfers(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_ft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_ft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_ft_transfer_bool_exp
	): [erc_ft_transfer!]!

	"""
	An aggregate relationship
	"""
	ft_transfers_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_ft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_ft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_ft_transfer_bool_exp
	): erc_ft_transfer_aggregate!
	id: String!
	name: String
	symbol: String
}

"""
aggregated selection of "squid_erc.f_token"
"""
type erc_f_token_aggregate {
	aggregate: erc_f_token_aggregate_fields
	nodes: [erc_f_token!]!
}

"""
aggregate fields of "squid_erc.f_token"
"""
type erc_f_token_aggregate_fields {
	avg: erc_f_token_avg_fields
	count(columns: [erc_f_token_select_column!], distinct: Boolean): Int!
	max: erc_f_token_max_fields
	min: erc_f_token_min_fields
	stddev: erc_f_token_stddev_fields
	stddev_pop: erc_f_token_stddev_pop_fields
	stddev_samp: erc_f_token_stddev_samp_fields
	sum: erc_f_token_sum_fields
	var_pop: erc_f_token_var_pop_fields
	var_samp: erc_f_token_var_samp_fields
	variance: erc_f_token_variance_fields
}

"""
aggregate avg on columns
"""
type erc_f_token_avg_fields {
	decimals: Float
}

"""
Boolean expression to filter rows from the table "squid_erc.f_token". All fields are combined with a logical 'AND'.
"""
input erc_f_token_bool_exp {
	_and: [erc_f_token_bool_exp!]
	_not: erc_f_token_bool_exp
	_or: [erc_f_token_bool_exp!]
	account_f_token_balances: erc_account_f_token_balance_bool_exp
	decimals: Int_comparison_exp
	ft_transfers: erc_ft_transfer_bool_exp
	id: String_comparison_exp
	name: String_comparison_exp
	symbol: String_comparison_exp
}

"""
unique or primary key constraints on table "squid_erc.f_token"
"""
enum erc_f_token_constraint {
	"""
	unique or primary key constraint on columns "id"
	"""
	PK_da896c08df3022e579355d781b9
}

"""
input type for incrementing numeric columns in table "squid_erc.f_token"
"""
input erc_f_token_inc_input {
	decimals: Int
}

"""
input type for inserting data into table "squid_erc.f_token"
"""
input erc_f_token_insert_input {
	account_f_token_balances: erc_account_f_token_balance_arr_rel_insert_input
	decimals: Int
	ft_transfers: erc_ft_transfer_arr_rel_insert_input
	id: String
	name: String
	symbol: String
}

"""
aggregate max on columns
"""
type erc_f_token_max_fields {
	decimals: Int
	id: String
	name: String
	symbol: String
}

"""
aggregate min on columns
"""
type erc_f_token_min_fields {
	decimals: Int
	id: String
	name: String
	symbol: String
}

"""
response of any mutation on the table "squid_erc.f_token"
"""
type erc_f_token_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!

	"""
	data from the rows affected by the mutation
	"""
	returning: [erc_f_token!]!
}

"""
input type for inserting object relation for remote table "squid_erc.f_token"
"""
input erc_f_token_obj_rel_insert_input {
	data: erc_f_token_insert_input!

	"""
	upsert condition
	"""
	on_conflict: erc_f_token_on_conflict
}

"""
on_conflict condition type for table "squid_erc.f_token"
"""
input erc_f_token_on_conflict {
	constraint: erc_f_token_constraint!
	update_columns: [erc_f_token_update_column!]! = []
	where: erc_f_token_bool_exp
}

"""
Ordering options when selecting data from "squid_erc.f_token".
"""
input erc_f_token_order_by {
	account_f_token_balances_aggregate: erc_account_f_token_balance_aggregate_order_by
	decimals: order_by
	ft_transfers_aggregate: erc_ft_transfer_aggregate_order_by
	id: order_by
	name: order_by
	symbol: order_by
}

"""
primary key columns input for table: f_token
"""
input erc_f_token_pk_columns_input {
	id: String!
}

"""
select columns of table "squid_erc.f_token"
"""
enum erc_f_token_select_column {
	"""
	column name
	"""
	decimals

	"""
	column name
	"""
	id

	"""
	column name
	"""
	name

	"""
	column name
	"""
	symbol
}

"""
input type for updating data in table "squid_erc.f_token"
"""
input erc_f_token_set_input {
	decimals: Int
	id: String
	name: String
	symbol: String
}

"""
aggregate stddev on columns
"""
type erc_f_token_stddev_fields {
	decimals: Float
}

"""
aggregate stddev_pop on columns
"""
type erc_f_token_stddev_pop_fields {
	decimals: Float
}

"""
aggregate stddev_samp on columns
"""
type erc_f_token_stddev_samp_fields {
	decimals: Float
}

"""
Streaming cursor of the table "f_token"
"""
input erc_f_token_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: erc_f_token_stream_cursor_value_input!

	"""
	cursor ordering
	"""
	ordering: erc_cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input erc_f_token_stream_cursor_value_input {
	decimals: Int
	id: String
	name: String
	symbol: String
}

"""
aggregate sum on columns
"""
type erc_f_token_sum_fields {
	decimals: Int
}

"""
update columns of table "squid_erc.f_token"
"""
enum erc_f_token_update_column {
	"""
	column name
	"""
	decimals

	"""
	column name
	"""
	id

	"""
	column name
	"""
	name

	"""
	column name
	"""
	symbol
}

input erc_f_token_updates {
	"""
	increments the numeric columns with given value of the filtered values
	"""
	_inc: erc_f_token_inc_input

	"""
	sets the columns of the filtered rows to the given values
	"""
	_set: erc_f_token_set_input
	where: erc_f_token_bool_exp!
}

"""
aggregate var_pop on columns
"""
type erc_f_token_var_pop_fields {
	decimals: Float
}

"""
aggregate var_samp on columns
"""
type erc_f_token_var_samp_fields {
	decimals: Float
}

"""
aggregate variance on columns
"""
type erc_f_token_variance_fields {
	decimals: Float
}

"""
columns and relationships of "squid_erc.ft_transfer"
"""
type erc_ft_transfer {
	"""
	An object relationship
	"""
	account: erc_account!

	"""
	An object relationship
	"""
	accountByToId: erc_account!

	"""
	An array relationship
	"""
	account_ft_transfers(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_account_ft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_account_ft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_account_ft_transfer_bool_exp
	): [erc_account_ft_transfer!]!

	"""
	An aggregate relationship
	"""
	account_ft_transfers_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_account_ft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_account_ft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_account_ft_transfer_bool_exp
	): erc_account_ft_transfer_aggregate!
	amount: numeric
	block_number: numeric!
	event_index: Int!

	"""
	An object relationship
	"""
	f_token: erc_f_token!
	from_id: String!
	id: String!
	timestamp: timestamptz!
	to_id: String!
	token_id: String!
	transfer_type: String
	txn_hash: String!
}

"""
aggregated selection of "squid_erc.ft_transfer"
"""
type erc_ft_transfer_aggregate {
	aggregate: erc_ft_transfer_aggregate_fields
	nodes: [erc_ft_transfer!]!
}

"""
aggregate fields of "squid_erc.ft_transfer"
"""
type erc_ft_transfer_aggregate_fields {
	avg: erc_ft_transfer_avg_fields
	count(columns: [erc_ft_transfer_select_column!], distinct: Boolean): Int!
	max: erc_ft_transfer_max_fields
	min: erc_ft_transfer_min_fields
	stddev: erc_ft_transfer_stddev_fields
	stddev_pop: erc_ft_transfer_stddev_pop_fields
	stddev_samp: erc_ft_transfer_stddev_samp_fields
	sum: erc_ft_transfer_sum_fields
	var_pop: erc_ft_transfer_var_pop_fields
	var_samp: erc_ft_transfer_var_samp_fields
	variance: erc_ft_transfer_variance_fields
}

"""
order by aggregate values of table "squid_erc.ft_transfer"
"""
input erc_ft_transfer_aggregate_order_by {
	avg: erc_ft_transfer_avg_order_by
	count: order_by
	max: erc_ft_transfer_max_order_by
	min: erc_ft_transfer_min_order_by
	stddev: erc_ft_transfer_stddev_order_by
	stddev_pop: erc_ft_transfer_stddev_pop_order_by
	stddev_samp: erc_ft_transfer_stddev_samp_order_by
	sum: erc_ft_transfer_sum_order_by
	var_pop: erc_ft_transfer_var_pop_order_by
	var_samp: erc_ft_transfer_var_samp_order_by
	variance: erc_ft_transfer_variance_order_by
}

"""
input type for inserting array relation for remote table "squid_erc.ft_transfer"
"""
input erc_ft_transfer_arr_rel_insert_input {
	data: [erc_ft_transfer_insert_input!]!

	"""
	upsert condition
	"""
	on_conflict: erc_ft_transfer_on_conflict
}

"""
aggregate avg on columns
"""
type erc_ft_transfer_avg_fields {
	amount: Float
	block_number: Float
	event_index: Float
}

"""
order by avg() on columns of table "squid_erc.ft_transfer"
"""
input erc_ft_transfer_avg_order_by {
	amount: order_by
	block_number: order_by
	event_index: order_by
}

"""
Boolean expression to filter rows from the table "squid_erc.ft_transfer". All fields are combined with a logical 'AND'.
"""
input erc_ft_transfer_bool_exp {
	_and: [erc_ft_transfer_bool_exp!]
	_not: erc_ft_transfer_bool_exp
	_or: [erc_ft_transfer_bool_exp!]
	account: erc_account_bool_exp
	accountByToId: erc_account_bool_exp
	account_ft_transfers: erc_account_ft_transfer_bool_exp
	amount: numeric_comparison_exp
	block_number: numeric_comparison_exp
	event_index: Int_comparison_exp
	f_token: erc_f_token_bool_exp
	from_id: String_comparison_exp
	id: String_comparison_exp
	timestamp: timestamptz_comparison_exp
	to_id: String_comparison_exp
	token_id: String_comparison_exp
	transfer_type: String_comparison_exp
	txn_hash: String_comparison_exp
}

"""
unique or primary key constraints on table "squid_erc.ft_transfer"
"""
enum erc_ft_transfer_constraint {
	"""
	unique or primary key constraint on columns "id"
	"""
	PK_9197e98e6e5fc3ead382a4b80a3
}

"""
input type for incrementing numeric columns in table "squid_erc.ft_transfer"
"""
input erc_ft_transfer_inc_input {
	amount: numeric
	block_number: numeric
	event_index: Int
}

"""
input type for inserting data into table "squid_erc.ft_transfer"
"""
input erc_ft_transfer_insert_input {
	account: erc_account_obj_rel_insert_input
	accountByToId: erc_account_obj_rel_insert_input
	account_ft_transfers: erc_account_ft_transfer_arr_rel_insert_input
	amount: numeric
	block_number: numeric
	event_index: Int
	f_token: erc_f_token_obj_rel_insert_input
	from_id: String
	id: String
	timestamp: timestamptz
	to_id: String
	token_id: String
	transfer_type: String
	txn_hash: String
}

"""
aggregate max on columns
"""
type erc_ft_transfer_max_fields {
	amount: numeric
	block_number: numeric
	event_index: Int
	from_id: String
	id: String
	timestamp: timestamptz
	to_id: String
	token_id: String
	transfer_type: String
	txn_hash: String
}

"""
order by max() on columns of table "squid_erc.ft_transfer"
"""
input erc_ft_transfer_max_order_by {
	amount: order_by
	block_number: order_by
	event_index: order_by
	from_id: order_by
	id: order_by
	timestamp: order_by
	to_id: order_by
	token_id: order_by
	transfer_type: order_by
	txn_hash: order_by
}

"""
aggregate min on columns
"""
type erc_ft_transfer_min_fields {
	amount: numeric
	block_number: numeric
	event_index: Int
	from_id: String
	id: String
	timestamp: timestamptz
	to_id: String
	token_id: String
	transfer_type: String
	txn_hash: String
}

"""
order by min() on columns of table "squid_erc.ft_transfer"
"""
input erc_ft_transfer_min_order_by {
	amount: order_by
	block_number: order_by
	event_index: order_by
	from_id: order_by
	id: order_by
	timestamp: order_by
	to_id: order_by
	token_id: order_by
	transfer_type: order_by
	txn_hash: order_by
}

"""
response of any mutation on the table "squid_erc.ft_transfer"
"""
type erc_ft_transfer_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!

	"""
	data from the rows affected by the mutation
	"""
	returning: [erc_ft_transfer!]!
}

"""
input type for inserting object relation for remote table "squid_erc.ft_transfer"
"""
input erc_ft_transfer_obj_rel_insert_input {
	data: erc_ft_transfer_insert_input!

	"""
	upsert condition
	"""
	on_conflict: erc_ft_transfer_on_conflict
}

"""
on_conflict condition type for table "squid_erc.ft_transfer"
"""
input erc_ft_transfer_on_conflict {
	constraint: erc_ft_transfer_constraint!
	update_columns: [erc_ft_transfer_update_column!]! = []
	where: erc_ft_transfer_bool_exp
}

"""
Ordering options when selecting data from "squid_erc.ft_transfer".
"""
input erc_ft_transfer_order_by {
	account: erc_account_order_by
	accountByToId: erc_account_order_by
	account_ft_transfers_aggregate: erc_account_ft_transfer_aggregate_order_by
	amount: order_by
	block_number: order_by
	event_index: order_by
	f_token: erc_f_token_order_by
	from_id: order_by
	id: order_by
	timestamp: order_by
	to_id: order_by
	token_id: order_by
	transfer_type: order_by
	txn_hash: order_by
}

"""
primary key columns input for table: ft_transfer
"""
input erc_ft_transfer_pk_columns_input {
	id: String!
}

"""
select columns of table "squid_erc.ft_transfer"
"""
enum erc_ft_transfer_select_column {
	"""
	column name
	"""
	amount

	"""
	column name
	"""
	block_number

	"""
	column name
	"""
	event_index

	"""
	column name
	"""
	from_id

	"""
	column name
	"""
	id

	"""
	column name
	"""
	timestamp

	"""
	column name
	"""
	to_id

	"""
	column name
	"""
	token_id

	"""
	column name
	"""
	transfer_type

	"""
	column name
	"""
	txn_hash
}

"""
input type for updating data in table "squid_erc.ft_transfer"
"""
input erc_ft_transfer_set_input {
	amount: numeric
	block_number: numeric
	event_index: Int
	from_id: String
	id: String
	timestamp: timestamptz
	to_id: String
	token_id: String
	transfer_type: String
	txn_hash: String
}

"""
aggregate stddev on columns
"""
type erc_ft_transfer_stddev_fields {
	amount: Float
	block_number: Float
	event_index: Float
}

"""
order by stddev() on columns of table "squid_erc.ft_transfer"
"""
input erc_ft_transfer_stddev_order_by {
	amount: order_by
	block_number: order_by
	event_index: order_by
}

"""
aggregate stddev_pop on columns
"""
type erc_ft_transfer_stddev_pop_fields {
	amount: Float
	block_number: Float
	event_index: Float
}

"""
order by stddev_pop() on columns of table "squid_erc.ft_transfer"
"""
input erc_ft_transfer_stddev_pop_order_by {
	amount: order_by
	block_number: order_by
	event_index: order_by
}

"""
aggregate stddev_samp on columns
"""
type erc_ft_transfer_stddev_samp_fields {
	amount: Float
	block_number: Float
	event_index: Float
}

"""
order by stddev_samp() on columns of table "squid_erc.ft_transfer"
"""
input erc_ft_transfer_stddev_samp_order_by {
	amount: order_by
	block_number: order_by
	event_index: order_by
}

"""
Streaming cursor of the table "ft_transfer"
"""
input erc_ft_transfer_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: erc_ft_transfer_stream_cursor_value_input!

	"""
	cursor ordering
	"""
	ordering: erc_cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input erc_ft_transfer_stream_cursor_value_input {
	amount: numeric
	block_number: numeric
	event_index: Int
	from_id: String
	id: String
	timestamp: timestamptz
	to_id: String
	token_id: String
	transfer_type: String
	txn_hash: String
}

"""
aggregate sum on columns
"""
type erc_ft_transfer_sum_fields {
	amount: numeric
	block_number: numeric
	event_index: Int
}

"""
order by sum() on columns of table "squid_erc.ft_transfer"
"""
input erc_ft_transfer_sum_order_by {
	amount: order_by
	block_number: order_by
	event_index: order_by
}

"""
update columns of table "squid_erc.ft_transfer"
"""
enum erc_ft_transfer_update_column {
	"""
	column name
	"""
	amount

	"""
	column name
	"""
	block_number

	"""
	column name
	"""
	event_index

	"""
	column name
	"""
	from_id

	"""
	column name
	"""
	id

	"""
	column name
	"""
	timestamp

	"""
	column name
	"""
	to_id

	"""
	column name
	"""
	token_id

	"""
	column name
	"""
	transfer_type

	"""
	column name
	"""
	txn_hash
}

input erc_ft_transfer_updates {
	"""
	increments the numeric columns with given value of the filtered values
	"""
	_inc: erc_ft_transfer_inc_input

	"""
	sets the columns of the filtered rows to the given values
	"""
	_set: erc_ft_transfer_set_input
	where: erc_ft_transfer_bool_exp!
}

"""
aggregate var_pop on columns
"""
type erc_ft_transfer_var_pop_fields {
	amount: Float
	block_number: Float
	event_index: Float
}

"""
order by var_pop() on columns of table "squid_erc.ft_transfer"
"""
input erc_ft_transfer_var_pop_order_by {
	amount: order_by
	block_number: order_by
	event_index: order_by
}

"""
aggregate var_samp on columns
"""
type erc_ft_transfer_var_samp_fields {
	amount: Float
	block_number: Float
	event_index: Float
}

"""
order by var_samp() on columns of table "squid_erc.ft_transfer"
"""
input erc_ft_transfer_var_samp_order_by {
	amount: order_by
	block_number: order_by
	event_index: order_by
}

"""
aggregate variance on columns
"""
type erc_ft_transfer_variance_fields {
	amount: Float
	block_number: Float
	event_index: Float
}

"""
order by variance() on columns of table "squid_erc.ft_transfer"
"""
input erc_ft_transfer_variance_order_by {
	amount: order_by
	block_number: order_by
	event_index: order_by
}

"""
columns and relationships of "squid_erc.nf_token"
"""
type erc_nf_token {
	"""
	An object relationship
	"""
	account: erc_account!
	amount: numeric!

	"""
	An object relationship
	"""
	collection: erc_collection!
	collection_id: String!
	current_owner_id: String!
	id: String!
	is_burned: Boolean!
	name: String
	native_id: String!

	"""
	An array relationship
	"""
	nft_transfers(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_nft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_nft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_nft_transfer_bool_exp
	): [erc_nft_transfer!]!

	"""
	An aggregate relationship
	"""
	nft_transfers_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_nft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_nft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_nft_transfer_bool_exp
	): erc_nft_transfer_aggregate!
	symbol: String
	uri: String

	"""
	An array relationship
	"""
	uri_update_actions(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_uri_update_action_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_uri_update_action_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_uri_update_action_bool_exp
	): [erc_uri_update_action!]!

	"""
	An aggregate relationship
	"""
	uri_update_actions_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_uri_update_action_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_uri_update_action_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_uri_update_action_bool_exp
	): erc_uri_update_action_aggregate!
}

"""
aggregated selection of "squid_erc.nf_token"
"""
type erc_nf_token_aggregate {
	aggregate: erc_nf_token_aggregate_fields
	nodes: [erc_nf_token!]!
}

"""
aggregate fields of "squid_erc.nf_token"
"""
type erc_nf_token_aggregate_fields {
	avg: erc_nf_token_avg_fields
	count(columns: [erc_nf_token_select_column!], distinct: Boolean): Int!
	max: erc_nf_token_max_fields
	min: erc_nf_token_min_fields
	stddev: erc_nf_token_stddev_fields
	stddev_pop: erc_nf_token_stddev_pop_fields
	stddev_samp: erc_nf_token_stddev_samp_fields
	sum: erc_nf_token_sum_fields
	var_pop: erc_nf_token_var_pop_fields
	var_samp: erc_nf_token_var_samp_fields
	variance: erc_nf_token_variance_fields
}

"""
order by aggregate values of table "squid_erc.nf_token"
"""
input erc_nf_token_aggregate_order_by {
	avg: erc_nf_token_avg_order_by
	count: order_by
	max: erc_nf_token_max_order_by
	min: erc_nf_token_min_order_by
	stddev: erc_nf_token_stddev_order_by
	stddev_pop: erc_nf_token_stddev_pop_order_by
	stddev_samp: erc_nf_token_stddev_samp_order_by
	sum: erc_nf_token_sum_order_by
	var_pop: erc_nf_token_var_pop_order_by
	var_samp: erc_nf_token_var_samp_order_by
	variance: erc_nf_token_variance_order_by
}

"""
input type for inserting array relation for remote table "squid_erc.nf_token"
"""
input erc_nf_token_arr_rel_insert_input {
	data: [erc_nf_token_insert_input!]!

	"""
	upsert condition
	"""
	on_conflict: erc_nf_token_on_conflict
}

"""
aggregate avg on columns
"""
type erc_nf_token_avg_fields {
	amount: Float
}

"""
order by avg() on columns of table "squid_erc.nf_token"
"""
input erc_nf_token_avg_order_by {
	amount: order_by
}

"""
Boolean expression to filter rows from the table "squid_erc.nf_token". All fields are combined with a logical 'AND'.
"""
input erc_nf_token_bool_exp {
	_and: [erc_nf_token_bool_exp!]
	_not: erc_nf_token_bool_exp
	_or: [erc_nf_token_bool_exp!]
	account: erc_account_bool_exp
	amount: numeric_comparison_exp
	collection: erc_collection_bool_exp
	collection_id: String_comparison_exp
	current_owner_id: String_comparison_exp
	id: String_comparison_exp
	is_burned: Boolean_comparison_exp
	name: String_comparison_exp
	native_id: String_comparison_exp
	nft_transfers: erc_nft_transfer_bool_exp
	symbol: String_comparison_exp
	uri: String_comparison_exp
	uri_update_actions: erc_uri_update_action_bool_exp
}

"""
unique or primary key constraints on table "squid_erc.nf_token"
"""
enum erc_nf_token_constraint {
	"""
	unique or primary key constraint on columns "id"
	"""
	PK_4b875f332d287d53286f0120060
}

"""
input type for incrementing numeric columns in table "squid_erc.nf_token"
"""
input erc_nf_token_inc_input {
	amount: numeric
}

"""
input type for inserting data into table "squid_erc.nf_token"
"""
input erc_nf_token_insert_input {
	account: erc_account_obj_rel_insert_input
	amount: numeric
	collection: erc_collection_obj_rel_insert_input
	collection_id: String
	current_owner_id: String
	id: String
	is_burned: Boolean
	name: String
	native_id: String
	nft_transfers: erc_nft_transfer_arr_rel_insert_input
	symbol: String
	uri: String
	uri_update_actions: erc_uri_update_action_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type erc_nf_token_max_fields {
	amount: numeric
	collection_id: String
	current_owner_id: String
	id: String
	name: String
	native_id: String
	symbol: String
	uri: String
}

"""
order by max() on columns of table "squid_erc.nf_token"
"""
input erc_nf_token_max_order_by {
	amount: order_by
	collection_id: order_by
	current_owner_id: order_by
	id: order_by
	name: order_by
	native_id: order_by
	symbol: order_by
	uri: order_by
}

"""
aggregate min on columns
"""
type erc_nf_token_min_fields {
	amount: numeric
	collection_id: String
	current_owner_id: String
	id: String
	name: String
	native_id: String
	symbol: String
	uri: String
}

"""
order by min() on columns of table "squid_erc.nf_token"
"""
input erc_nf_token_min_order_by {
	amount: order_by
	collection_id: order_by
	current_owner_id: order_by
	id: order_by
	name: order_by
	native_id: order_by
	symbol: order_by
	uri: order_by
}

"""
response of any mutation on the table "squid_erc.nf_token"
"""
type erc_nf_token_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!

	"""
	data from the rows affected by the mutation
	"""
	returning: [erc_nf_token!]!
}

"""
input type for inserting object relation for remote table "squid_erc.nf_token"
"""
input erc_nf_token_obj_rel_insert_input {
	data: erc_nf_token_insert_input!

	"""
	upsert condition
	"""
	on_conflict: erc_nf_token_on_conflict
}

"""
on_conflict condition type for table "squid_erc.nf_token"
"""
input erc_nf_token_on_conflict {
	constraint: erc_nf_token_constraint!
	update_columns: [erc_nf_token_update_column!]! = []
	where: erc_nf_token_bool_exp
}

"""
Ordering options when selecting data from "squid_erc.nf_token".
"""
input erc_nf_token_order_by {
	account: erc_account_order_by
	amount: order_by
	collection: erc_collection_order_by
	collection_id: order_by
	current_owner_id: order_by
	id: order_by
	is_burned: order_by
	name: order_by
	native_id: order_by
	nft_transfers_aggregate: erc_nft_transfer_aggregate_order_by
	symbol: order_by
	uri: order_by
	uri_update_actions_aggregate: erc_uri_update_action_aggregate_order_by
}

"""
primary key columns input for table: nf_token
"""
input erc_nf_token_pk_columns_input {
	id: String!
}

"""
select columns of table "squid_erc.nf_token"
"""
enum erc_nf_token_select_column {
	"""
	column name
	"""
	amount

	"""
	column name
	"""
	collection_id

	"""
	column name
	"""
	current_owner_id

	"""
	column name
	"""
	id

	"""
	column name
	"""
	is_burned

	"""
	column name
	"""
	name

	"""
	column name
	"""
	native_id

	"""
	column name
	"""
	symbol

	"""
	column name
	"""
	uri
}

"""
input type for updating data in table "squid_erc.nf_token"
"""
input erc_nf_token_set_input {
	amount: numeric
	collection_id: String
	current_owner_id: String
	id: String
	is_burned: Boolean
	name: String
	native_id: String
	symbol: String
	uri: String
}

"""
aggregate stddev on columns
"""
type erc_nf_token_stddev_fields {
	amount: Float
}

"""
order by stddev() on columns of table "squid_erc.nf_token"
"""
input erc_nf_token_stddev_order_by {
	amount: order_by
}

"""
aggregate stddev_pop on columns
"""
type erc_nf_token_stddev_pop_fields {
	amount: Float
}

"""
order by stddev_pop() on columns of table "squid_erc.nf_token"
"""
input erc_nf_token_stddev_pop_order_by {
	amount: order_by
}

"""
aggregate stddev_samp on columns
"""
type erc_nf_token_stddev_samp_fields {
	amount: Float
}

"""
order by stddev_samp() on columns of table "squid_erc.nf_token"
"""
input erc_nf_token_stddev_samp_order_by {
	amount: order_by
}

"""
Streaming cursor of the table "nf_token"
"""
input erc_nf_token_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: erc_nf_token_stream_cursor_value_input!

	"""
	cursor ordering
	"""
	ordering: erc_cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input erc_nf_token_stream_cursor_value_input {
	amount: numeric
	collection_id: String
	current_owner_id: String
	id: String
	is_burned: Boolean
	name: String
	native_id: String
	symbol: String
	uri: String
}

"""
aggregate sum on columns
"""
type erc_nf_token_sum_fields {
	amount: numeric
}

"""
order by sum() on columns of table "squid_erc.nf_token"
"""
input erc_nf_token_sum_order_by {
	amount: order_by
}

"""
update columns of table "squid_erc.nf_token"
"""
enum erc_nf_token_update_column {
	"""
	column name
	"""
	amount

	"""
	column name
	"""
	collection_id

	"""
	column name
	"""
	current_owner_id

	"""
	column name
	"""
	id

	"""
	column name
	"""
	is_burned

	"""
	column name
	"""
	name

	"""
	column name
	"""
	native_id

	"""
	column name
	"""
	symbol

	"""
	column name
	"""
	uri
}

input erc_nf_token_updates {
	"""
	increments the numeric columns with given value of the filtered values
	"""
	_inc: erc_nf_token_inc_input

	"""
	sets the columns of the filtered rows to the given values
	"""
	_set: erc_nf_token_set_input
	where: erc_nf_token_bool_exp!
}

"""
aggregate var_pop on columns
"""
type erc_nf_token_var_pop_fields {
	amount: Float
}

"""
order by var_pop() on columns of table "squid_erc.nf_token"
"""
input erc_nf_token_var_pop_order_by {
	amount: order_by
}

"""
aggregate var_samp on columns
"""
type erc_nf_token_var_samp_fields {
	amount: Float
}

"""
order by var_samp() on columns of table "squid_erc.nf_token"
"""
input erc_nf_token_var_samp_order_by {
	amount: order_by
}

"""
aggregate variance on columns
"""
type erc_nf_token_variance_fields {
	amount: Float
}

"""
order by variance() on columns of table "squid_erc.nf_token"
"""
input erc_nf_token_variance_order_by {
	amount: order_by
}

"""
columns and relationships of "squid_erc.nft_transfer"
"""
type erc_nft_transfer {
	"""
	An object relationship
	"""
	account: erc_account

	"""
	An object relationship
	"""
	accountByFromId: erc_account!

	"""
	An object relationship
	"""
	accountByToId: erc_account!

	"""
	An array relationship
	"""
	account_nft_transfers(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_account_nft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_account_nft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_account_nft_transfer_bool_exp
	): [erc_account_nft_transfer!]!

	"""
	An aggregate relationship
	"""
	account_nft_transfers_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [erc_account_nft_transfer_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [erc_account_nft_transfer_order_by!]

		"""
		filter the rows returned
		"""
		where: erc_account_nft_transfer_bool_exp
	): erc_account_nft_transfer_aggregate!
	amount: numeric!
	block_number: numeric!
	event_index: Int!
	from_id: String!
	id: String!
	is_batch: Boolean!

	"""
	An object relationship
	"""
	nf_token: erc_nf_token!
	operator_id: String
	timestamp: timestamptz!
	to_id: String!
	token_id: String!
	transfer_type: String
	txn_hash: String!
}

"""
aggregated selection of "squid_erc.nft_transfer"
"""
type erc_nft_transfer_aggregate {
	aggregate: erc_nft_transfer_aggregate_fields
	nodes: [erc_nft_transfer!]!
}

"""
aggregate fields of "squid_erc.nft_transfer"
"""
type erc_nft_transfer_aggregate_fields {
	avg: erc_nft_transfer_avg_fields
	count(columns: [erc_nft_transfer_select_column!], distinct: Boolean): Int!
	max: erc_nft_transfer_max_fields
	min: erc_nft_transfer_min_fields
	stddev: erc_nft_transfer_stddev_fields
	stddev_pop: erc_nft_transfer_stddev_pop_fields
	stddev_samp: erc_nft_transfer_stddev_samp_fields
	sum: erc_nft_transfer_sum_fields
	var_pop: erc_nft_transfer_var_pop_fields
	var_samp: erc_nft_transfer_var_samp_fields
	variance: erc_nft_transfer_variance_fields
}

"""
order by aggregate values of table "squid_erc.nft_transfer"
"""
input erc_nft_transfer_aggregate_order_by {
	avg: erc_nft_transfer_avg_order_by
	count: order_by
	max: erc_nft_transfer_max_order_by
	min: erc_nft_transfer_min_order_by
	stddev: erc_nft_transfer_stddev_order_by
	stddev_pop: erc_nft_transfer_stddev_pop_order_by
	stddev_samp: erc_nft_transfer_stddev_samp_order_by
	sum: erc_nft_transfer_sum_order_by
	var_pop: erc_nft_transfer_var_pop_order_by
	var_samp: erc_nft_transfer_var_samp_order_by
	variance: erc_nft_transfer_variance_order_by
}

"""
input type for inserting array relation for remote table "squid_erc.nft_transfer"
"""
input erc_nft_transfer_arr_rel_insert_input {
	data: [erc_nft_transfer_insert_input!]!

	"""
	upsert condition
	"""
	on_conflict: erc_nft_transfer_on_conflict
}

"""
aggregate avg on columns
"""
type erc_nft_transfer_avg_fields {
	amount: Float
	block_number: Float
	event_index: Float
}

"""
order by avg() on columns of table "squid_erc.nft_transfer"
"""
input erc_nft_transfer_avg_order_by {
	amount: order_by
	block_number: order_by
	event_index: order_by
}

"""
Boolean expression to filter rows from the table "squid_erc.nft_transfer". All fields are combined with a logical 'AND'.
"""
input erc_nft_transfer_bool_exp {
	_and: [erc_nft_transfer_bool_exp!]
	_not: erc_nft_transfer_bool_exp
	_or: [erc_nft_transfer_bool_exp!]
	account: erc_account_bool_exp
	accountByFromId: erc_account_bool_exp
	accountByToId: erc_account_bool_exp
	account_nft_transfers: erc_account_nft_transfer_bool_exp
	amount: numeric_comparison_exp
	block_number: numeric_comparison_exp
	event_index: Int_comparison_exp
	from_id: String_comparison_exp
	id: String_comparison_exp
	is_batch: Boolean_comparison_exp
	nf_token: erc_nf_token_bool_exp
	operator_id: String_comparison_exp
	timestamp: timestamptz_comparison_exp
	to_id: String_comparison_exp
	token_id: String_comparison_exp
	transfer_type: String_comparison_exp
	txn_hash: String_comparison_exp
}

"""
unique or primary key constraints on table "squid_erc.nft_transfer"
"""
enum erc_nft_transfer_constraint {
	"""
	unique or primary key constraint on columns "id"
	"""
	PK_2d9d4b37560ecbcae8bd13026ab
}

"""
input type for incrementing numeric columns in table "squid_erc.nft_transfer"
"""
input erc_nft_transfer_inc_input {
	amount: numeric
	block_number: numeric
	event_index: Int
}

"""
input type for inserting data into table "squid_erc.nft_transfer"
"""
input erc_nft_transfer_insert_input {
	account: erc_account_obj_rel_insert_input
	accountByFromId: erc_account_obj_rel_insert_input
	accountByToId: erc_account_obj_rel_insert_input
	account_nft_transfers: erc_account_nft_transfer_arr_rel_insert_input
	amount: numeric
	block_number: numeric
	event_index: Int
	from_id: String
	id: String
	is_batch: Boolean
	nf_token: erc_nf_token_obj_rel_insert_input
	operator_id: String
	timestamp: timestamptz
	to_id: String
	token_id: String
	transfer_type: String
	txn_hash: String
}

"""
aggregate max on columns
"""
type erc_nft_transfer_max_fields {
	amount: numeric
	block_number: numeric
	event_index: Int
	from_id: String
	id: String
	operator_id: String
	timestamp: timestamptz
	to_id: String
	token_id: String
	transfer_type: String
	txn_hash: String
}

"""
order by max() on columns of table "squid_erc.nft_transfer"
"""
input erc_nft_transfer_max_order_by {
	amount: order_by
	block_number: order_by
	event_index: order_by
	from_id: order_by
	id: order_by
	operator_id: order_by
	timestamp: order_by
	to_id: order_by
	token_id: order_by
	transfer_type: order_by
	txn_hash: order_by
}

"""
aggregate min on columns
"""
type erc_nft_transfer_min_fields {
	amount: numeric
	block_number: numeric
	event_index: Int
	from_id: String
	id: String
	operator_id: String
	timestamp: timestamptz
	to_id: String
	token_id: String
	transfer_type: String
	txn_hash: String
}

"""
order by min() on columns of table "squid_erc.nft_transfer"
"""
input erc_nft_transfer_min_order_by {
	amount: order_by
	block_number: order_by
	event_index: order_by
	from_id: order_by
	id: order_by
	operator_id: order_by
	timestamp: order_by
	to_id: order_by
	token_id: order_by
	transfer_type: order_by
	txn_hash: order_by
}

"""
response of any mutation on the table "squid_erc.nft_transfer"
"""
type erc_nft_transfer_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!

	"""
	data from the rows affected by the mutation
	"""
	returning: [erc_nft_transfer!]!
}

"""
input type for inserting object relation for remote table "squid_erc.nft_transfer"
"""
input erc_nft_transfer_obj_rel_insert_input {
	data: erc_nft_transfer_insert_input!

	"""
	upsert condition
	"""
	on_conflict: erc_nft_transfer_on_conflict
}

"""
on_conflict condition type for table "squid_erc.nft_transfer"
"""
input erc_nft_transfer_on_conflict {
	constraint: erc_nft_transfer_constraint!
	update_columns: [erc_nft_transfer_update_column!]! = []
	where: erc_nft_transfer_bool_exp
}

"""
Ordering options when selecting data from "squid_erc.nft_transfer".
"""
input erc_nft_transfer_order_by {
	account: erc_account_order_by
	accountByFromId: erc_account_order_by
	accountByToId: erc_account_order_by
	account_nft_transfers_aggregate: erc_account_nft_transfer_aggregate_order_by
	amount: order_by
	block_number: order_by
	event_index: order_by
	from_id: order_by
	id: order_by
	is_batch: order_by
	nf_token: erc_nf_token_order_by
	operator_id: order_by
	timestamp: order_by
	to_id: order_by
	token_id: order_by
	transfer_type: order_by
	txn_hash: order_by
}

"""
primary key columns input for table: nft_transfer
"""
input erc_nft_transfer_pk_columns_input {
	id: String!
}

"""
select columns of table "squid_erc.nft_transfer"
"""
enum erc_nft_transfer_select_column {
	"""
	column name
	"""
	amount

	"""
	column name
	"""
	block_number

	"""
	column name
	"""
	event_index

	"""
	column name
	"""
	from_id

	"""
	column name
	"""
	id

	"""
	column name
	"""
	is_batch

	"""
	column name
	"""
	operator_id

	"""
	column name
	"""
	timestamp

	"""
	column name
	"""
	to_id

	"""
	column name
	"""
	token_id

	"""
	column name
	"""
	transfer_type

	"""
	column name
	"""
	txn_hash
}

"""
input type for updating data in table "squid_erc.nft_transfer"
"""
input erc_nft_transfer_set_input {
	amount: numeric
	block_number: numeric
	event_index: Int
	from_id: String
	id: String
	is_batch: Boolean
	operator_id: String
	timestamp: timestamptz
	to_id: String
	token_id: String
	transfer_type: String
	txn_hash: String
}

"""
aggregate stddev on columns
"""
type erc_nft_transfer_stddev_fields {
	amount: Float
	block_number: Float
	event_index: Float
}

"""
order by stddev() on columns of table "squid_erc.nft_transfer"
"""
input erc_nft_transfer_stddev_order_by {
	amount: order_by
	block_number: order_by
	event_index: order_by
}

"""
aggregate stddev_pop on columns
"""
type erc_nft_transfer_stddev_pop_fields {
	amount: Float
	block_number: Float
	event_index: Float
}

"""
order by stddev_pop() on columns of table "squid_erc.nft_transfer"
"""
input erc_nft_transfer_stddev_pop_order_by {
	amount: order_by
	block_number: order_by
	event_index: order_by
}

"""
aggregate stddev_samp on columns
"""
type erc_nft_transfer_stddev_samp_fields {
	amount: Float
	block_number: Float
	event_index: Float
}

"""
order by stddev_samp() on columns of table "squid_erc.nft_transfer"
"""
input erc_nft_transfer_stddev_samp_order_by {
	amount: order_by
	block_number: order_by
	event_index: order_by
}

"""
Streaming cursor of the table "nft_transfer"
"""
input erc_nft_transfer_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: erc_nft_transfer_stream_cursor_value_input!

	"""
	cursor ordering
	"""
	ordering: erc_cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input erc_nft_transfer_stream_cursor_value_input {
	amount: numeric
	block_number: numeric
	event_index: Int
	from_id: String
	id: String
	is_batch: Boolean
	operator_id: String
	timestamp: timestamptz
	to_id: String
	token_id: String
	transfer_type: String
	txn_hash: String
}

"""
aggregate sum on columns
"""
type erc_nft_transfer_sum_fields {
	amount: numeric
	block_number: numeric
	event_index: Int
}

"""
order by sum() on columns of table "squid_erc.nft_transfer"
"""
input erc_nft_transfer_sum_order_by {
	amount: order_by
	block_number: order_by
	event_index: order_by
}

"""
update columns of table "squid_erc.nft_transfer"
"""
enum erc_nft_transfer_update_column {
	"""
	column name
	"""
	amount

	"""
	column name
	"""
	block_number

	"""
	column name
	"""
	event_index

	"""
	column name
	"""
	from_id

	"""
	column name
	"""
	id

	"""
	column name
	"""
	is_batch

	"""
	column name
	"""
	operator_id

	"""
	column name
	"""
	timestamp

	"""
	column name
	"""
	to_id

	"""
	column name
	"""
	token_id

	"""
	column name
	"""
	transfer_type

	"""
	column name
	"""
	txn_hash
}

input erc_nft_transfer_updates {
	"""
	increments the numeric columns with given value of the filtered values
	"""
	_inc: erc_nft_transfer_inc_input

	"""
	sets the columns of the filtered rows to the given values
	"""
	_set: erc_nft_transfer_set_input
	where: erc_nft_transfer_bool_exp!
}

"""
aggregate var_pop on columns
"""
type erc_nft_transfer_var_pop_fields {
	amount: Float
	block_number: Float
	event_index: Float
}

"""
order by var_pop() on columns of table "squid_erc.nft_transfer"
"""
input erc_nft_transfer_var_pop_order_by {
	amount: order_by
	block_number: order_by
	event_index: order_by
}

"""
aggregate var_samp on columns
"""
type erc_nft_transfer_var_samp_fields {
	amount: Float
	block_number: Float
	event_index: Float
}

"""
order by var_samp() on columns of table "squid_erc.nft_transfer"
"""
input erc_nft_transfer_var_samp_order_by {
	amount: order_by
	block_number: order_by
	event_index: order_by
}

"""
aggregate variance on columns
"""
type erc_nft_transfer_variance_fields {
	amount: Float
	block_number: Float
	event_index: Float
}

"""
order by variance() on columns of table "squid_erc.nft_transfer"
"""
input erc_nft_transfer_variance_order_by {
	amount: order_by
	block_number: order_by
	event_index: order_by
}

"""
columns and relationships of "squid_erc.uri_update_action"
"""
type erc_uri_update_action {
	block_number: numeric!
	id: String!
	new_value: String

	"""
	An object relationship
	"""
	nf_token: erc_nf_token!
	old_value: String
	timestamp: timestamptz!
	token_id: String!
	txn_hash: String!
}

"""
aggregated selection of "squid_erc.uri_update_action"
"""
type erc_uri_update_action_aggregate {
	aggregate: erc_uri_update_action_aggregate_fields
	nodes: [erc_uri_update_action!]!
}

"""
aggregate fields of "squid_erc.uri_update_action"
"""
type erc_uri_update_action_aggregate_fields {
	avg: erc_uri_update_action_avg_fields
	count(
		columns: [erc_uri_update_action_select_column!]
		distinct: Boolean
	): Int!
	max: erc_uri_update_action_max_fields
	min: erc_uri_update_action_min_fields
	stddev: erc_uri_update_action_stddev_fields
	stddev_pop: erc_uri_update_action_stddev_pop_fields
	stddev_samp: erc_uri_update_action_stddev_samp_fields
	sum: erc_uri_update_action_sum_fields
	var_pop: erc_uri_update_action_var_pop_fields
	var_samp: erc_uri_update_action_var_samp_fields
	variance: erc_uri_update_action_variance_fields
}

"""
order by aggregate values of table "squid_erc.uri_update_action"
"""
input erc_uri_update_action_aggregate_order_by {
	avg: erc_uri_update_action_avg_order_by
	count: order_by
	max: erc_uri_update_action_max_order_by
	min: erc_uri_update_action_min_order_by
	stddev: erc_uri_update_action_stddev_order_by
	stddev_pop: erc_uri_update_action_stddev_pop_order_by
	stddev_samp: erc_uri_update_action_stddev_samp_order_by
	sum: erc_uri_update_action_sum_order_by
	var_pop: erc_uri_update_action_var_pop_order_by
	var_samp: erc_uri_update_action_var_samp_order_by
	variance: erc_uri_update_action_variance_order_by
}

"""
input type for inserting array relation for remote table "squid_erc.uri_update_action"
"""
input erc_uri_update_action_arr_rel_insert_input {
	data: [erc_uri_update_action_insert_input!]!

	"""
	upsert condition
	"""
	on_conflict: erc_uri_update_action_on_conflict
}

"""
aggregate avg on columns
"""
type erc_uri_update_action_avg_fields {
	block_number: Float
}

"""
order by avg() on columns of table "squid_erc.uri_update_action"
"""
input erc_uri_update_action_avg_order_by {
	block_number: order_by
}

"""
Boolean expression to filter rows from the table "squid_erc.uri_update_action". All fields are combined with a logical 'AND'.
"""
input erc_uri_update_action_bool_exp {
	_and: [erc_uri_update_action_bool_exp!]
	_not: erc_uri_update_action_bool_exp
	_or: [erc_uri_update_action_bool_exp!]
	block_number: numeric_comparison_exp
	id: String_comparison_exp
	new_value: String_comparison_exp
	nf_token: erc_nf_token_bool_exp
	old_value: String_comparison_exp
	timestamp: timestamptz_comparison_exp
	token_id: String_comparison_exp
	txn_hash: String_comparison_exp
}

"""
unique or primary key constraints on table "squid_erc.uri_update_action"
"""
enum erc_uri_update_action_constraint {
	"""
	unique or primary key constraint on columns "id"
	"""
	PK_0de40fe0fe070f895e84d31ecd0
}

"""
input type for incrementing numeric columns in table "squid_erc.uri_update_action"
"""
input erc_uri_update_action_inc_input {
	block_number: numeric
}

"""
input type for inserting data into table "squid_erc.uri_update_action"
"""
input erc_uri_update_action_insert_input {
	block_number: numeric
	id: String
	new_value: String
	nf_token: erc_nf_token_obj_rel_insert_input
	old_value: String
	timestamp: timestamptz
	token_id: String
	txn_hash: String
}

"""
aggregate max on columns
"""
type erc_uri_update_action_max_fields {
	block_number: numeric
	id: String
	new_value: String
	old_value: String
	timestamp: timestamptz
	token_id: String
	txn_hash: String
}

"""
order by max() on columns of table "squid_erc.uri_update_action"
"""
input erc_uri_update_action_max_order_by {
	block_number: order_by
	id: order_by
	new_value: order_by
	old_value: order_by
	timestamp: order_by
	token_id: order_by
	txn_hash: order_by
}

"""
aggregate min on columns
"""
type erc_uri_update_action_min_fields {
	block_number: numeric
	id: String
	new_value: String
	old_value: String
	timestamp: timestamptz
	token_id: String
	txn_hash: String
}

"""
order by min() on columns of table "squid_erc.uri_update_action"
"""
input erc_uri_update_action_min_order_by {
	block_number: order_by
	id: order_by
	new_value: order_by
	old_value: order_by
	timestamp: order_by
	token_id: order_by
	txn_hash: order_by
}

"""
response of any mutation on the table "squid_erc.uri_update_action"
"""
type erc_uri_update_action_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!

	"""
	data from the rows affected by the mutation
	"""
	returning: [erc_uri_update_action!]!
}

"""
on_conflict condition type for table "squid_erc.uri_update_action"
"""
input erc_uri_update_action_on_conflict {
	constraint: erc_uri_update_action_constraint!
	update_columns: [erc_uri_update_action_update_column!]! = []
	where: erc_uri_update_action_bool_exp
}

"""
Ordering options when selecting data from "squid_erc.uri_update_action".
"""
input erc_uri_update_action_order_by {
	block_number: order_by
	id: order_by
	new_value: order_by
	nf_token: erc_nf_token_order_by
	old_value: order_by
	timestamp: order_by
	token_id: order_by
	txn_hash: order_by
}

"""
primary key columns input for table: uri_update_action
"""
input erc_uri_update_action_pk_columns_input {
	id: String!
}

"""
select columns of table "squid_erc.uri_update_action"
"""
enum erc_uri_update_action_select_column {
	"""
	column name
	"""
	block_number

	"""
	column name
	"""
	id

	"""
	column name
	"""
	new_value

	"""
	column name
	"""
	old_value

	"""
	column name
	"""
	timestamp

	"""
	column name
	"""
	token_id

	"""
	column name
	"""
	txn_hash
}

"""
input type for updating data in table "squid_erc.uri_update_action"
"""
input erc_uri_update_action_set_input {
	block_number: numeric
	id: String
	new_value: String
	old_value: String
	timestamp: timestamptz
	token_id: String
	txn_hash: String
}

"""
aggregate stddev on columns
"""
type erc_uri_update_action_stddev_fields {
	block_number: Float
}

"""
order by stddev() on columns of table "squid_erc.uri_update_action"
"""
input erc_uri_update_action_stddev_order_by {
	block_number: order_by
}

"""
aggregate stddev_pop on columns
"""
type erc_uri_update_action_stddev_pop_fields {
	block_number: Float
}

"""
order by stddev_pop() on columns of table "squid_erc.uri_update_action"
"""
input erc_uri_update_action_stddev_pop_order_by {
	block_number: order_by
}

"""
aggregate stddev_samp on columns
"""
type erc_uri_update_action_stddev_samp_fields {
	block_number: Float
}

"""
order by stddev_samp() on columns of table "squid_erc.uri_update_action"
"""
input erc_uri_update_action_stddev_samp_order_by {
	block_number: order_by
}

"""
Streaming cursor of the table "uri_update_action"
"""
input erc_uri_update_action_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: erc_uri_update_action_stream_cursor_value_input!

	"""
	cursor ordering
	"""
	ordering: erc_cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input erc_uri_update_action_stream_cursor_value_input {
	block_number: numeric
	id: String
	new_value: String
	old_value: String
	timestamp: timestamptz
	token_id: String
	txn_hash: String
}

"""
aggregate sum on columns
"""
type erc_uri_update_action_sum_fields {
	block_number: numeric
}

"""
order by sum() on columns of table "squid_erc.uri_update_action"
"""
input erc_uri_update_action_sum_order_by {
	block_number: order_by
}

"""
update columns of table "squid_erc.uri_update_action"
"""
enum erc_uri_update_action_update_column {
	"""
	column name
	"""
	block_number

	"""
	column name
	"""
	id

	"""
	column name
	"""
	new_value

	"""
	column name
	"""
	old_value

	"""
	column name
	"""
	timestamp

	"""
	column name
	"""
	token_id

	"""
	column name
	"""
	txn_hash
}

input erc_uri_update_action_updates {
	"""
	increments the numeric columns with given value of the filtered values
	"""
	_inc: erc_uri_update_action_inc_input

	"""
	sets the columns of the filtered rows to the given values
	"""
	_set: erc_uri_update_action_set_input
	where: erc_uri_update_action_bool_exp!
}

"""
aggregate var_pop on columns
"""
type erc_uri_update_action_var_pop_fields {
	block_number: Float
}

"""
order by var_pop() on columns of table "squid_erc.uri_update_action"
"""
input erc_uri_update_action_var_pop_order_by {
	block_number: order_by
}

"""
aggregate var_samp on columns
"""
type erc_uri_update_action_var_samp_fields {
	block_number: Float
}

"""
order by var_samp() on columns of table "squid_erc.uri_update_action"
"""
input erc_uri_update_action_var_samp_order_by {
	block_number: order_by
}

"""
aggregate variance on columns
"""
type erc_uri_update_action_variance_fields {
	block_number: Float
}

"""
order by variance() on columns of table "squid_erc.uri_update_action"
"""
input erc_uri_update_action_variance_order_by {
	block_number: order_by
}

scalar jsonb

input jsonb_cast_exp {
	String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
	_cast: jsonb_cast_exp

	"""
	is the column contained in the given json value
	"""
	_contained_in: jsonb

	"""
	does the column contain the given json value at the top level
	"""
	_contains: jsonb
	_eq: jsonb
	_gt: jsonb
	_gte: jsonb

	"""
	does the string exist as a top-level key in the column
	"""
	_has_key: String

	"""
	do all of these strings exist as top-level keys in the column
	"""
	_has_keys_all: [String!]

	"""
	do any of these strings exist as top-level keys in the column
	"""
	_has_keys_any: [String!]
	_in: [jsonb!]
	_is_null: Boolean
	_lt: jsonb
	_lte: jsonb
	_neq: jsonb
	_nin: [jsonb!]
}

"""
mutation root
"""
type mutation_root {
	archive: archive_archive_mutation_frontend
	balances: balances_balances_mutation_frontend
	erc: erc_erc_mutation_frontend
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
	_eq: numeric
	_gt: numeric
	_gte: numeric
	_in: [numeric!]
	_is_null: Boolean
	_lt: numeric
	_lte: numeric
	_neq: numeric
	_nin: [numeric!]
}

"""
column ordering options
"""
enum order_by {
	"""
	in ascending order, nulls last
	"""
	asc

	"""
	in ascending order, nulls first
	"""
	asc_nulls_first

	"""
	in ascending order, nulls last
	"""
	asc_nulls_last

	"""
	in descending order, nulls first
	"""
	desc

	"""
	in descending order, nulls first
	"""
	desc_nulls_first

	"""
	in descending order, nulls last
	"""
	desc_nulls_last
}

type query_root {
	archive: archive_archive_query
	balances: balances_balances_query
	erc: erc_erc_query
}

type subscription_root {
	archive: archive_archive_subscription
	balances: balances_balances_subscription
	erc: erc_erc_subscription
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
	_eq: timestamptz
	_gt: timestamptz
	_gte: timestamptz
	_in: [timestamptz!]
	_is_null: Boolean
	_lt: timestamptz
	_lte: timestamptz
	_neq: timestamptz
	_nin: [timestamptz!]
}
